[{"ref":"https://2222-42.github.io/2021/03/14/how-to-exchange-memory-2/","title":"How to Exchange Memory 2","section":"post","date":"2021.03.14","body":"だいぶ前にCORSAIRのメモリを交換したので、残りについて記録しておく。\n前回は、問合せとその結果、交換できることまでわかった。 今回は、実際に返品する方法(返品できない方法)と、実際にどれくらいで返品されたかを見ていく。\n返品する方法 まずは、Corsairから貰った、発送票とcommercial Invoiceの2つを印刷しておくこと。\n返品できない方法 お近くのDHLに直接持ち込んではいけない。\n返品の場合の国際発送は、ほとんどの店舗では対応していない。\n返品するための方法 DHLのカスタマーサポートに電話して、Corsairから貰ったPDFに含まれるデータ(発送票の方)の番号を伝える。サポートセンターが番号を確認し、確認が終わり次第、集荷についてお願いができる。\n返品するために必要な書類 電話でも説明を受けるが、発送票とCommercial Invoiceは、集荷の人に渡すのに必要。\nしてはいけないこと 荷物に発送票は貼り付けなくていい。\n集荷の人に発送票とCommercial Invoiceをそのまま渡して。\n返品までにかかる時間 台湾に届くまでにかかる時間は地域によって変わるのでここで話しても明確にはわからない。ただし、DHLでは税関に先に商品内容を伝えているので、税関で時間がかかることはない。\n台湾に届いてからは、一日以内に次の商品の発送がされる。(私の場合は1時間かからずに発送の連絡が来た)。\n台湾から日本への発送もDHLのため、かなり早かった。\nまとめ 問題の原因特定や、買い物の保証期間を確かめること、またDHLの店舗では送れなかったことを調べること、これらにもっとも時間がかかった。\nカスタマーサポートとのやり取りや発送にかかるコストはとても少なかった。\nみんなへの提案 面倒くさがらずに電話をしよう。私はDHLの店舗に直接持っていけばいいやと思って持っていったら諸事情で2店舗を渡り歩いて結局電話して解決というオチになった。\n"},{"ref":"https://2222-42.github.io/2021/01/16/log-of-studying-rust-3/","title":"Log of Studying Rust 3","section":"post","date":"2021.01.16","body":"2020年12月26日から2020年12月31日 のRustの勉強記録\nTRPL pp. 324-347\n13.5 ループとイテレータをパフォーマンスの比較をする\nイテレータは、\n 高度な抽象化に関わらず、低レベルなコードを地震で書いているかのように、ほぼ同じコードにコンパイルされる  ループを展開し、ループ制御コードのオーバーヘッドを除去し、代わりにループの繰り返しごとに同じコードを作成 ゼロコスト抽象  抽象化を使うことが追加の実行時オーバーヘッドを産まないことを意味する C++ のゼロオーバーヘッドと類似      13.6 低レベルのパフォーマンスで、高レベルの考えを明確に表現するというRustの能力に貢献\n14 Cargoの色々な機能\n14.1 リリースプロファイルでビルドをカスタマイズする。\n dev プロファイル  cargo buildで利用される 開発中に役立つデフォルト設定がされている   release プロファイル  cargo build --relaseで利用される リリース用の設定がなされてりう    Cargo.tomlファイルに[profile.*]セクションを追加することでデフォルト設定の一部を上書きする\ne.g., opt-levelは最適化の度合いで0(dev)から3(release)まで\n14.2 Crates.ioにクレートを公開する\n14.2.1 ドキュメンテーションコメント\n 三連スラッシュ(///)で始める。  コードコメントは二連スラッシュ(//) Markdown記法もサポート   他のユーザーがパッケージについて理解する手助けになるから書くことに時間を費やす価値はある cargo docを実行することでHTML Documentを生成できる  target/docディレクトリに配置される    14.2.1.1 よく使われるセクション\n Examples  例   Panics  panic!する可能性のある筋書   Errors  関数がResultを返すなら、  起きうるエラーの種類と どんな条件がそれらのエラーを引き起こすか   の解説をするかしょ   Safety  関数が呼び出すのにunsafeなら、その理由の説明と期待する不変条件を記述    14.2.1.2 ドキュメンテーションコメントにコードブロックを追加すると、cargo testでドキュメントのコード例をテストとして実行する。 動かない例がついているよりも悪いものはない。\n ///  コメントに続く要素にドキュメンテーションを付け加える   //!  コメントを含む要素にドキュメンテーションを付け加える クレートやモジュール全体にドキュメントを付ける クレートの目的や体系を説明するのに有用 //!で始まる最後の行のあとにコードを入れない    14.2.2  modで体系化 pubで公開 useでスコープに導入  これらは開発する自分にとって意味ある構造であり、使用者よりも開発者に関係すること\nユーザーにとってはそうではない。 使用者にとって役立つ構造を含んでいないし、use文で指定するのは不便。\n再構築する必要なしに、要素を再エクスポートし、自分の非公開構造とは異なる公開構造にできる。 もちろん内部構造を見て使用することもできる。 これはクレートの使用経験に大きな違いを生む。\n14.2.3 クレートを公開するためにやること\n crates.ioにアカウントを登録 APIキーを発行 cargo login cargo publish  14.2.4  Cargo.tomlファイルの[package]セクションに  名前(name)を追加  名前はcrates.ioで早い者勝ち   ライセンス(license)にライセンス識別子を  SPDEのもの それ以外はファイルを配置せよ   説明文 authors　 version  セマンティックバージョンルールを使用して公開      14.2.5, 14.2.6 crates.ioに公開したら永久にアーカイブされる。決して削除されない。\ncrates.ioの1つの主な目標が、crates.ioのクレートに依存している全てのプロジェクトのビルドが動き続けるようにすること\nyank(取り下げ)はできる。それのundoもできる。取り下げると新規のプロジェクトは新たに依存できない。既存のは使い続けられる。\n14.3 ライブラリクレートが肥大化したら、服須のライブラリクレートに分割したくなる。\nワークスペース:\n 関連のある複数のパッケージを管理するのに役立つ 同じCargo.lockと同じ出力ディレクトリを共有する一連のパッケージ  最上位にtargetのディレクトリがあり、下位のにはtargetディレクトリがない なぜなら、ワークスペースのクレートは互いに依存しあうことを意味する    やり方:\n ワークスペース用の新しいディレクトリを追加する。 ワークスペース全体を設定するCargo.tomlファイルを作成する  [workspace]セクションから開始 members = [\u0026quot;xxx\u0026quot;, ...]   そのディレクトリ内でcargo newを実行し、クレートを追加する cargo buildを走らせるとワークスペースを構築できる  14.3.2 メンバクレートの追加とその使用\n メンバクレートを作成  membersリストで新たなパスを追加 その名前のライブラリクレートを作成   メンバクレート間での依存を記述  一方のメンバクレートのCargo.tomlにそれへのパス依存を追加する  Cargoはワークスペースのクレートがお互いに依存しているとは想定していないので、クレート間の依存関係について明示する必要がある     メンバクレートの関数を使用する  extern crate行を追加してスコープを導入   cargo build 最上位のディレクトリからバイナリを実行する方法は、cargo run -p (パッケージ名)  メンバクレートのパス依存を追加する方法\n[dependencies] yy = {path = \u0026#34;../yy\u0026#34;} 14.3.2.1  ワークスペースの最上位階層にただ1つのCargo.lock 全クレートが全依存の同じバージョンを使用する  スペースの節約 ワークスペースのクレートが相互に互換性を維持する    それぞれのクレートのCargo.tomlファイルに外部クレートを追加する\nbuildすると最上位のCargo.lockに、それに対する依存の情報を含むようになる\n最上位のCargo.lockにその外部クレートが存在しても それぞれのクレートのCargo.tomlファイルにもそれが存在しない限り、その外部クレートを使用することはできない。 これで、明示的に依存していることを示す。\n14.3.2.2 個別のクレートにテストを追加する\nワークスペースの最上位のディレクトリで、\n cargo testを実行するとワークスペースの全クレートのテストを実行する -pフラグを使用し、テストしたいクレータオの名前を指定することで最上位ディレクトリから、ワークスペースのある特定のクレート用のテストを実行することができる  ワークスペースのクレートの公開は個別にそれぞれの各クレートを公開しなければならない\nワークスペースの利用の利点:\n 個別のコンポーネントの方が理解しやすい 変更されることが多いなら、クレートを保持することは、強調しやすくすることにもつながる  14.4 cargo installで、crates.ioから\n バイナリクレートを  バイナリターゲット(単独で実行可能なプログラム)を持つパッケージのみインストールできる   ローカルにインストールし  binフォルダに保持される   使用することができる  実行できるようにするためには、そのディレクトリが$PATHに含まれている    14.5 $PATHにあるバイナリが、 cargo-somethingという名前なら、 cargo somethingとサブコマンドであるかのように実行できるように拡張することができる\ncargo installと拡張しやすさ、これら2つの組み合わせはCargoの設計上の非常に便利な恩恵\n"},{"ref":"https://2222-42.github.io/2021/01/04/log-of-studying-rust-2/","title":"Log of Studying Rust 2","section":"post","date":"2021.01.04","body":"2020年12月22日から2020年12月25日 のRustの勉強記録\nTRPL pp. 303-324\n13.1.3 クロージャやクロージャの呼び出し結果の値を保持する構造体を作る\n 結果の値が必要な場合  その構造体に格納されている値があるかを確認  あったら、それを使う。(クロージャを実行しない) なければ、クロージャを実行し、その結果の値をキャッシュする      これはメモ化、遅延評価と呼ばれるパターンで、残りのコードは結果を保存し再利用する責任を追わずに済む。\nクロージャを保持する構造体を作成したい\n クロージャの型を指定する必要がある。  各クロージャインスタンスには独自の匿名の型がある。   クロージャを使用する構造体、enum、関数引数を定義するには、ジェネリックスとトレイト境界を使用する。  Fn トレイト境界に型を追加して、このトレイト境界に合致するクロージャが持つべき引数と戻り値の型を示す   クロージャは以下のいずれかのトレイトを実装する。(なお、関数は3つのトレイト全部を実装する。環境から値をキャプチャする必要がなければ関数を使用できる)  Fn FnMut FnOnce   クロージャとその結果を保存する構造体をimplする  フィールドは非公開にする  なぜなら、呼び出し元は変更できないように、つまり、Cacherに構造体のフィールドの値を管理してほしいから。   評価結果が欲しければ、valueメソッドを呼ぶようにする  Someならば、その結果を Noneならば、クロージャを呼び出し、その結果を構造体に保存し、その結果を返す     この構造体のメリット:  重い計算を最大1回で済ませられるようにする この保証をするのに必要なロジックの面倒は構造体が見る  呼び出し元はビジネスロジックに集中できる      クロージャを変数に直接保存する代わりに、クロージャを保持する構造体の新規インスタンスを保存する。\n13.1.4 Cacher実装で課題になること: 他の文脈での再利用性\n 常にvalueメソッドの引数argに対して、同じ値を想定しており、更新できない。  -\u0026gt; ハッシュマップを保持するようにしよう   引数の型、返り値の型が固定で、柔軟ではない  -\u0026gt; ジェネリックな引数を導入するようにしよう    13.1.5 クロージャは:\n 環境をキャプチャし、 自分が定義されたスコープにアクセスできる  メモリを使用して、クロージャ本体で使用できるように、その値を保存する  これはオーバーヘッド 関数は環境をキャプチャすることが赦されていないので、オーバーヘッドを招かない      クロージャの環境から値をキャプチャする3つの方法\n Fn  不変借用   FnMut  可変借用   FnOnce  所有権を奪い、自分にムーブする  2回以上奪えないからOnce      所有権を奪うことをクロージャーに強制したいなら、引数リストの前にmoveキーワードを付ける\nFnトレイトのどれかを指定するほとんどの場合のプラクティス:\n Fnから始める コンパイラがFnMutやFnOnceが必要な場合は教えてくれる  環境をキャプチャできるクロージャが関数の引数として有用な場面はイテレータ\n13.2 イテレータパターンにより、一連の要素に順番に何らかの作業を行うことができる。\nイテレータ:\n 各要素を繰り返し、シーケンスが終わったことを決定するロジックの責任を負う。  イテレータが存在しない言語だと、変数を添え字0から始め、添え字アクセスし、総要素数に到達するまでループするよう、その変数の値をインクリメントする、というロジックを書く必要がある。   添え字を使えるデータ構造以外でも同じロジックを使える  イテレータの生成とその使用は別個であるが、forでまとめてもよい。\n13.2.1 Iteratorトレイトは以下のようなものであり、1つのメソッドのみを定義することを実装者に要求する。それはnext。\npub trait Iterator { type Item fn next(\u0026amp;mut self) -\u0026gt; Option(Self::Item) } Item型がイテレータから帰ってくる型になる。これを関連型と言う。\nなお、nextは直接呼ぶことも可能。\nnext:\n シーケンスのどこにいるかを追いかけるために、イテレータを消費する、各呼び出しごとに、イテレータが使用している内部状態が変わる  イテレータを可変にする必要がある  forループでは、ループがiterの所有権を奪い、陰で可変にしている。     nextで得られる値は不変な参照  iter:\n into_iterでは、  元の所有権を奪い、所有された値を返す イテレータを生成できる   iter_mutでは、可変参照を繰り返せる  13.2.2 Iteratorトレイトは、デフォルト実装のある多くの異なるメソッドがある。\nnextを呼び出すメソッドは、イテレータを消費することから、消費アダプタ(consuming adaptor)と呼ばれる\n例: sumメソッド:\n 各要素を一時的な合計に追加し、繰り返しが完了したらその合計を返す イテレータの所有権を奪うので、その後に元のイテレータは使用できなくなる。  13.3 イテレータアダプタ\n Iteratorトレイトに定義された消費アダプタ以外のメソッド イテレータを別の種類のイテレータに変えさせてくれる  複数回呼び出しを連結して、複雑な動作を読みやすい形で行える   消費アダプタメソッドのどれかを呼び出さないと何もしない  なぜなら、イテレータは怠惰だから  消費アダプタが呼ばれ、消費されるまで、何もしない  それまでは、mapで指定したクロージャを実行しない        イテレータアダプタの例: map(クロージャ)\n クロージャをとるので、各要素に対して行いたいどんな処理でも指定できる Iteratorトレイトが提供する繰り返し動作を再利用しつつ、クロージャにより一部の動作をカスタマイズできる好例である。  13.3.1 filter\n イテレータアダプタ イテレータの各要素を取り、論理値を返すクロージャを取る  クロージャがtrueを返すなら、  結果のイテレータにその値が含まれる   クロージャがfalseを返すなら、  結果のイテレータにその値が含まれない     クロージャを取るので、環境から変数をキャプチャうることができる。  13.3.2 イテレータの作成。ベクタ、ハッシュマップなど、コレクション型からできる。\nIteratorトレイトを自分で実装することでしたいことをなんでもするイテレータを作成できる。必要な定義の提供はnextメソッドのみ。\nデモ:\n 構造体を作る Iteratorトレイトを実装  impl Iterator for SomeStruct { type Item = \u0026#39;a; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { ... } } これでnextメソッドも他のIteratorトレイトメソッドを使用することができるようになる。\nデモで使っているzipは、入力イテレータのどちらかがNoneを返したら、Noneを返す。\n13.4.1 やりたいこと: 非効率なclone呼び出しを除外したい\n疑問: なぜcloneを使っていたか？\n スライスを借用していたから Configインスタンスの所有権を返すため  方法: イテレータでどうするか？\n 引数としてイテレータの所有権を奪うように変更する  借用する添え字アクセス処理をやめ、 イテレータからString値をConfigにムーブするようにする    13.4.1.1 env::args:\n イテレータを返す それをそのまま渡すようにする  libのシグニチャを更新する:\n env::Argsを型に取り かつ、所有権を奪い、繰り返しを行うので、可変mutにする  本体を更新する:\n添え字アクセスをやめ、添え字の場合の長さのチェックをやめ、nextメソッドを使い、Some/Noneでチェックする\n13.4.2 イテレータアダプタメソッドを使用すれば、可変な状態の良を最小化し、(イテレータアダプタとそのやっていることの間隔を掴めば、)コードが明瞭化され、ループの高難度の目的に集中できる。\nいろんなループを少しずつ弄んだり、新しいベクタを作ったりということをしなくて済む。\nイテレータアダプタメソッドを使うか、ループを使うかは、スタイルやパフォーマンスの問題がある。\n"},{"ref":"https://2222-42.github.io/2021/01/03/what-i-want-to-do-in-2021/","title":"What I Want to Do in 2021","section":"post","date":"2021.01.03","body":"今年の目標を立てる。 資格、プログラミング、形式手法、文化、健康、それらに関して目標を立てた。\n資格 基本情報技術者試験と応用情報技術者試験を受けようと思う。\nスタートアップ企業で色々やっているが、結局、基本的な知識が足りないのではないかと思っている。 例えば、BGPとかもよくわかっていないし、アジャイルとかもよくわかっていない。\nある人は高度情報処理技術者試験を受ければいいのでは、と提案してきてくれたが、上記の自分の知識不足に対する不安があるうちはそれに挑戦できそうにない。 この不安は大きく、何に対しても躊躇してしまい、AWSのあれこれとかを受ける気力が湧かない。 実績という生の事実ではなく、資格という形式的な事実が欲しい。\nあとは、転職をする際に、最低限の知識がちゃんとあることを証明できる証拠が欲しい。 (会社にキャリアアップのための補助金を制度として導入してもらうようお願いできたら、いいな。)\nプログラミング Rustの勉強を続ける。\n 今年中に、TRPL を読み終える。 仕事でRustを使っているプロジェクトの改善を行う。 何らかのライブラリを作る。  形式手法 今年は、Isabelleの勉強を引き続きする\n Concrete Semantics を読了し、 Isbell の Uniform Space を形式化しよう。  TLA+ 昨年は、Lamportの Specifying Systems を読み終え、TLA+の基本的な文法の学習を終えた。\nTLA+については、分散システム周りでの活用がより見込めるが、分散システム周りに関する興味がそれほどないことが判明した。 いくつかの種類のPaxosに関する論文を読んだが、それほど私の琴線に触れるものではなかった。\nIsabelle 今は Concrete Semantics を186ページまで読んでいる。 ただ、練習問題はほとんど解いていない。\nそこで、証明力やIsabelle力を高めることに注力したい。\nUniform Spaceを形式化する 完全正則性と一様化可能性との同値性などの基本定理の証明がないなどの課題がIsabelleではあるらしく、それの提案を友人から受けた。\nそういうわけで、IsbellのUniform Spaceを読んで、形式化しようと思う。\n文化 いい加減、装甲騎兵ボトムズを履修しようと思う。\nペールゼン・ファイルズが、入門としてはちょうどいいらしいので、そこからスタートしよう。\n健康 肝機能を改善する。\n食事、運動、睡眠を規則正しくする。\n"},{"ref":"https://2222-42.github.io/2021/01/02/20210102log/","title":"20210102log","section":"post","date":"2021.01.02","body":"新年であれど変わらず、けれど、季節のものは食べるようにした。\n『SINGLE TASK　一点集中術』を読んだので、それについてまとめた。\ndiary 新年であっても、一緒に祝う友も家族も恋人もいないので、勉強をする。\nTRPL を読んだり、 Concrete Semantics を読んだり、また、シングルタスクについての本を読んだりした。\nまた、季節のものはさすがに食べないといけないと思い、雑煮を作って食べた。\nsingle task デボラ・ザック著、栗木さつき訳『SINGLE TASK　一点集中術』を読んだ。\n自分はマルチタスクというか、同じ期間に複数のISSUEを同時並行でやっており、マルチタスクになりがちなので、この本は読んでおきたかった。\nこれまでも聖書の読書プランで読んだ内容であったり、1on1の本で取り上げられている姿勢だったりしたが、改めて、重要だと記憶しているもの、そして、それを列挙していこう。\n 自分の時間を持ち、5分程度で日記を書き、自分の考えていることを整理する。  一人称より三人称で書いた方が、自分の問題を解決するためにはよい   「ささやかな例外」が失敗を招く 最も重要なことを選び、それに専念する その場に集中することが相手を大事にしていることを伝え、相手を大事にしていることを伝え、相手から信頼を得る方法である。 忙しい時は「ノー」と言ったり、15分だけね、と、相手に尊敬の念を込め、かつ断固として、それを伝える。  シングルタスクは、私も、仕事の量がやばいことになって、また、聖書アプリの読書プランで提案されて、導入し始めたから、その力は知っている。 さらに、『ヤフーの1on1』や『Team Geek』を読んで、他のことをやることが相手からの信頼を損なったり、また、「ノー」と言うことの重要性を学んできた。\nだが、改めて、自分がまだシングルタスクを実践できていないと感じている。\n"},{"ref":"https://2222-42.github.io/2021/01/01/what-i-learned-in-2020/","title":"What I Learned in 2020","section":"post","date":"2021.01.01","body":"2020年に学んだことリスト\nprogramming プログラミングに関して。\nStandard ML Standard MLは大堀さんの『Standard ML入門』を読んだ。\n20年前の著作にも関わらず、すごく読みやすくて、勉強しやすかった。\nまた、データ構造についても学ぶことができ、よかった。 自分は正規の教育を受けていないので、自分で考えて、自分で解いて、そして、それを筆者に尋ねられる環境はとてもよかった。\n『Standard ML入門』の解答例について これはとても良い本だと感じ、解答例を自分で作ろうと思っていたところ、筆者が解答例を公開した。\n解答例については、誤植や誤答があったので、それの修正案やコメントを筆者に直接メールで連絡した。これのおかげで、解答例のページに謝辞が掲載された。\nRust TRPLを今も勉強中である。\nSMLの勉強のおかげでかなり勉強しやすい。\nまた、13章までを終えることができた。\nworking 仕事に関して。\n仕事に関しては、人とのコミュニケーションやチームをどうしていくか、について多く学んだ。\nTeam 『Team Geek』を読み終え、 また、その内容をまとめて、社内で発表し、 そして、それを教育で活かせるようになった。\n学んだ内容、発表した内容で、 自分の仕事を改善することもでき、 また、チームメイトの悩みも一部解決できるようになったのはよかった。\nまた、キャリアやチーム、会社の方向性にも建設的な提案できるようになった。\n1on1 社内で1on1の一部を任せられるようになり、 他人とどうコミュニケーションをするか、他人の話を話をどう聴くか、をより学ぶようになった。\nさらに、他人のふり見てわがふり直せ、というのを直に感じるようになり、 自分の仕事のやり方やスケジューリングができるようになった。\nlife 人生に関して。\n人生に関しては、仕事と重複する部分もあるので、聖書に関してのみ言及する。\nBible 聖書アプリを使うようになり、 聖書日課を読んだり、 読書プランで自分を見直したりした。\npray およそ毎朝毎晩、神に祈りを捧げるようになった。\nsummary コロナの影響でリモートワークや休業が入り、自分の勉強をすることができるようになった。 好きなプログラミング言語を勉強できるのはよい。 さらに、規則正しい生活を心掛けるようになり、朝に勉強するようになった。\n会社に足りていないチームについて学ぶことができた。\n自分のキャリアプランを考え直す余裕ができた。\n聖書を読み返すようになり、 自分の魂に気を配るようになった。\n"},{"ref":"https://2222-42.github.io/2020/12/24/how-to-exchange-memory-1/","title":"How to Exchange Memory 1(First, to Contact)","section":"post","date":"2020.12.24","body":"CORSAIRのメモリの交換対応依頼をしたので、後続の人のために記録しておく。\ndiary pc PCの調子が悪くて、調査していたら、メモリが普通に壊れている。\nCORSAIRに交換のための問合せメールをした。\n交換承認の連絡が来た。\n一連の流れを記載しておく。\n問い合わせのために使用したデータ 公式サイトで、まず保証があるかどうかを確認。\nAmazonで購入したが日本の代理店のシールがあるかどうか -\u0026gt; ない\n公式サイトで問い合わせる方法を確認 -\u0026gt; 購入したサイトで問い合わせろ -\u0026gt; Amazonは交換をサポートしていない\n公式サイトでDRAMのサポートがあるか確認 -\u0026gt; 永久保証らしい\n必要なデータはなにか -\u0026gt; 購入証明書(INVOICE)、購入した商品のコード2つ(型番とシリアルコード)、あと、購入した商品のシリアルコードを含めた写真\n英語のサイトしかないから、英語でそれっぽい文章を作って交換したい旨を書く。 上記の4つを添付する。\n問合せ結果 なんか鬼のようなスピードで、確認、承認、そして発送方法の連絡のメールが来た。\nすごい早い勢いで仕事をしてくれて、かつ、承認もされたようで安心した。\nただ、海外発送なので、その方法については、調べて、またまとめようと思う。\n"},{"ref":"https://2222-42.github.io/2020/12/23/20201223log/","title":"20201223log","section":"post","date":"2020.12.23","body":"今日は健康に気を遣う日だった。\ndiary health 肝機能の問題について、年明けに精密検査の予約をした。 それまでにやることを色々考えてみた。\nfasting 間欠的断食を始めることにした。\n8時間は食べてもよくて、16時間食事をする、という手法である。\nこれまでと同じ内容の食事を8時間のうちに食べて、16時間は何も食べない。 16時間の間はノンカロリーなものはとっても良いものとする、というやつだ。\nこれで肝臓を休ませられたらな、と思う。\nnicotine ニコチンは肝臓に負担をかけるので、ニコチンを摂取する量を減らしていこうと思う。\nそのために、スヌースの摂取量を減らす。\nスヌースを摂取したらカレンダーで摂取していた時間の記録をとる。 そして、一時間以上時間を置く。\nあと、比較的ニコチン量が穏やかなパイプタバコを再開した。 日中の暖かい時間なら、窓を開け換気しながらパイプの煙を楽しむ。\nworkout 運動をするようにした。\nHIITを2日に1回やるようにしよう。\n今日は12分動いた。\nskin 肌の方はおおよそ治った。\nもうステロイドは使用しないことになった。\npipe パイプをいくつか手放すために、パイプ3本にSAをしている。\n"},{"ref":"https://2222-42.github.io/2020/12/23/log-of-studying-rust-1/","title":"log-of-studying-rust-1","section":"post","date":"2020.12.23","body":"15日から18日の分までのrustの勉強記録\nTRPL pp.286-303\n12章の続き コマンドラインオプションではなく、代わりに環境変数を使用するように変更する\nTDD:\n 失敗するテストを書く 古いテストを変更し、すでに実装済みの機能を誤って壊してしまわないことを保証 失敗する実装を作る 実装する  使っていたメソッド:\n to_lowercase  Stringを返す。  新しいデータ、新しいStringのメモリを確保している     contains  これのシグニチャは文字列slice  なので、Stringを渡すときは\u0026amp;をつける必要があった     env::varを使う  環境変数がsetされていたらOk列挙子を セットされていなかったらErr列挙子を返す   is_errを使う  Errだったらtrueを返す  この場合は、セットされていたらfalseを返すことになる。   値は関係ない場合は、unwrap, expect, Resultのメソッドは使う必要はない    引数と環境変数で同じ設定を行うことができるプログラム、そして、どちらが優先されるかを決定している、そんなプログラムを作る課題は解いた。\n出力について  標準出力(stdout): 普通の情報用 標準エラー出力(stderr): エラーメッセージ用  この差異のおかげで、エラーメッセージを画面に表示しつつ、プログラムが成功して出力をファイルに李大レスことすることをユーザーは選択できる。\nどのように標準出力に書き込まれているか。\n 標準エラーストリームはリダイレクトせず、全て画面に表示され続ける コマンドラインプログラムはエラーメッセージを標準エラー出力に送信することを期待する 標準出力の場合、\u0026gt;とfile名でfile名のfileにリダイレクトされ、保存される  求めるもの: エラーメッセージは標準エラーに出力され、成功した状態のデータのみはファイルに残ること\n標準エラーストリームに出力するマクロeprintln!(標準出力ストリームではない)\n13章 関数型言語に影響された機能の一部、\n クロージャ: 変数に保存できる関数に似た文保要素 イテレータ: 一連の要素を処理する方法  クロージャ クロージャは\n 変数に保存したり、引数として他の関数に渡すことのできる匿名関数  ある場所でクロージャを生成し、 そこから別の文脈でクロージャを呼び出して評価できる   関数と異なり、呼び出されたスコープの値をキャプチャできる  時間のかかる関数を2回呼び出しているケースで、どうやってリファクタしていくかで使い方を学んでいく。\n関数でリファクタリング 関数への重複した呼び出しの結果を変数に抽出しよう\n結果が本当に必要なところだけコードを実行したい\nクロージャでリファクタリング 呼び出しの結果を保存するのではなく、コードを定義するクロージャを変数に保存する\nlet name = |x| { ... v };  クロージャーのlet文は  結果の値ではなく、 匿名関数の定義を含むことを意味する   let文なので末尾に;が必要 一組の縦棒で、縦棒の中にクロージャーの仮引数を指定 関数の定義と同様に  クロージャー本体が式1つなら{、}を省略可能 {...}で関数の本体を書く  返り値を返すなら最終行に指定     クロージャは関数のように呼び出せる  複数回コードを呼び出す問題の再修正については、クロージャーが解決策を提供する。\nクロージャ定義に型注釈がない理由、および、クロージャに関わるトレイトについて  関数  ユーザーに露出する明示的なインターフェイスの一部  型を注釈する必要がある     クロージャ  露出するインターフェイスには使用されない短く狭い文脈でのみ関係する  型を注釈する必要がない 注釈を加えることもできる      クロージャ定義には、引数それぞれと戻り値に大して推論される具体的な型が1つある。 だから、2つの異なる型でクロージャーの呼び出しを試みると、1つ目の呼び出しの時点で型が推論されるので、2つ目の呼び出しで型エラーとなる。\n"},{"ref":"https://2222-42.github.io/2020/12/22/20201222log/","title":"20201222log","section":"post","date":"2020.12.22","body":"今日はある程度まとまった生活を送ることができた。コミュニケーションの重要性について改めて感じる。\ndiary communication 人となんらかの形でコミュニケートすることの重要性。\nコミュニケーションなしでは、コードの正しさは保証できないし、 自己のおかしい状態に気づくことはできない。\nshould let be done 「完了」した状態にすることが何よりも開発では重要なのであり、そのためには\n その「完了」を満たすのは、相手の求めているものを理解し、 その状態に持って行って、 相手からフィードバックをもらう  ということをしないといけない。 しかし、そういったことができていない人には、\n コミュニケーションをしてください、 どうすれば完了するかを考えてください 相手にそれを見せて反応をもらってください  としか伝えるしかない。\nこれがチームメイトや仲間であるならば、それを喜んで伝えるが、しかしながら、そうではないような人であるならば、お付き合いはしたくないね、という気分になる。\nhow to handle person confusing 混乱している人の話への対応方策の案が思いついた。\n 一度テキストデータとしてそのまま受け入れ、 信頼できる別の人と共有して、本質的な問題を抽出して、 共有したその人から、混乱している人にフィードバックする  多分、これが一番すっきりとした状態にさせることができると思った。\nstudy TRPLの勉強は今朝はできた。\n勉強記録のメモを毎日文字起こしするのは時間がかかって大変なので、週一で日記とは別でまとめた方がいいと思うようになった。\nteam 『Team Geek』の内容をもう一回まとめてスライドにしてYouTubeでボイチェンして発表するのをやりたくなってきた。\nhealth 健康診断結果を受けて、YouTubeに動画を投稿した。健康診断結果\n"},{"ref":"https://2222-42.github.io/2020/12/21/20201221log/","title":"20201221log","section":"post","date":"2020.12.21","body":"いいかげん、腹をくくったので、明日病院へ予約する。\ndiary 寝坊したので勉強できなかった。\nhealth 結局、消化器内科でどこに予約すればいいのか、どこが精密検査をしてくれるのかわからないのが困る。\nwork 仕事を何をもって完了とみなすか、ということを理解させるのが難しいので、そこを念入りに伝える。\n事業へのインパクトがあることを伝え、だから完了させないとけないということを伝えるために、現在の地点と、目指すべき地点、そしてそれに至るためにどうやるかを整理して伝えることもした。\n製品をよくしていこう、チームをよくしていこう、というのをこういった視点からまずは始めてみている。\n"},{"ref":"https://2222-42.github.io/2020/12/20/20201220log/","title":"20201220log","section":"post","date":"2020.12.20","body":"ここ数日寝込んでいた。寝込んでいた理由は以下の通りである。\n 体調が単純に悪かった。 健康診断の結果、肝機能が要診断であった。  結構健康に気を使った生活をしていただけにショックが大きい。   賃貸借契約の更新料がバカ高くて、どう捻出するかで悩んでいた。 寝込んで何も手がつかず、何もできないことでまた落ち込んで、と負のスパイラルに陥っていた。  liver 紹介状なんて貰ったのは、唾石症の時以来で、かつ、内臓系の紹介状は初めてなので、すごく戸惑っている。\n肝機能については、前回の診断の時は、まだデパスを利用していなかったので、これが関連しているかもしれない。\n落ち込んでもしょうがないから、とっとと精密検査をして、治してもらおう。\nmoney 金がないのは、いくつか不用品を売ってお金を稼ぐ。\nパイプを全然使わなくなったので、それをいくつか売ろうと思う。\nあと、会社に置いてあるiMacももう使わないと思うので、売ろうと思う。\nwork 何かをすることはすごく生産的に人をするから、あきらめずに動こうと思う。\n"},{"ref":"https://2222-42.github.io/2020/12/15/20201215log/","title":"20201215log","section":"post","date":"2020.12.15","body":"SSDが認識されなかったり、ブレーカーから異音がしたり、会社のWi-Fiの調子が悪くなったり、インフラに振り回される一日だった。\ndiary infra pc m.2 SSDが認識されなくて、換装がうまくいかず、中途半端で右往左往してしまい、時間を浪費してしまった。\n「存在しないデバイスを指定しました。」というエラーが出てきて、存在とは、となっていた。 (ここらへんのがすぐにネットでヒットしなかったから、対処したことをまとめて、整理しておこう。)\nサポートセンターに連絡し、とりあえず返答を待つ。もしかしたら、初期不良かもしれない。\nbraker ブレーカーから異音がするようになり、管理会社、電気工事店、東電、と色々な人を巻き込んで、やっとブレーカーを交換でき、異音もなくなった。\n"},{"ref":"https://2222-42.github.io/2020/12/14/20201214log/","title":"20201214log","section":"post","date":"2020.12.14","body":"余裕がない時こそ、余裕を設けることの重要さに気づくタイミングがあった。\ndiary pc M.2 SSDが届いた。 止めるためのねじがないので、何もできなかった。とりあえずねじを注文。\nrest 集中できない時は、集中できないので、別のことをに目を向ける。 すると、新たなことに気づける。\n日課の中で、立ち止まる、ということを設けるようにしている。 これの効果を今日改めて実感できた。\n余裕がないときこそ、余裕を設けることによって、余計な大変さをなくすことができるのだ、と改めて気づいた。\n今日の勉強 rust TRPL pp.278-286\nコードをライブラリクレートに分割する。\n 適宜pubをつけて公開にして、 extern crateでライブラリクレートをバイナリクレートに持っていって、 useしたり クレート名を接頭辞として付けたり  モジュール化を行った。\nモジュール性を利用してテストを活用する\nTDD\n 失敗するテストを書き、想定通りの理由で失敗することを確認する コーディングし、テストを通過するようにする リファクタリングして、テストが通り続けることを確認 1から繰り返す  失敗するテストを記述する\n testモジュールを追加する テスト関数で、実装しようとしているsearch関数に欲しい振る舞いを指定する 失敗するようなsearch関数の定義を追加  テストを通過するようにし、またリファクタリングする\n 条件に合致した行を保存するようにコーディングして、search関数のテストを通す  使った技術:  .lines  文字列を行ごとに繰り返すメソッド イテレーターを返す   containsメソッド呼び出し、クエリ文字列を含むかどうかチェックする 返すべくたを作れるように可変なベクタを作り、そこにpushし、最後にそれを返す     同じ機能を保持しながら、リファクタする  イテレーターの有用な機能を活用するということが残っている    あとは、mainが呼び出すところのrunからsearchを呼び出す。\n"},{"ref":"https://2222-42.github.io/2020/12/13/20201213log/","title":"20201213log","section":"post","date":"2020.12.13","body":"だいぶ体調が復活してきた。\ndiary health 体調がよくなってきた。\nfebc 今日のFEBCは神水教会だった。 熊本にいたころ何度か訪れたことがある。\nまた、日本福音ルーテルの式文は馴染んでいるものであり、各種のフレーズや音程もすぐに口から出てきた。\nこれは自分の悪いところなのであるが、礼拝の内容をすぐに忘れてしまう。 何度も似たような話を聞いているからでもあるが、 なんというか身が入らない。 やはり、直接礼拝堂に赴かないと、私は集中できないのだろうか。\npray 主よ、あなたの声に耳を傾けさせてください。\n弱っているときも、しっかりしているときも、あなたが共におられることを私の心に思い出させてください。\nfood ご飯をそこそこ多く食べることができるようになった。 運動を二日に一回しっかりとするようになったおかげでもあろう。 また、無理な温冷シャワーを避け、仕事をする日の朝だけにしたことも実は効果があるのかもしれない。\nまた、食事の好みにおいては、発酵食品が最近は好んで食べるようになった。 特に、納豆については、毎朝食べるようになった。 一種類だけの発酵食品をとるのはあまりよくないので、べったら漬けも今日は買った。\n今日の勉強 rust TRPL pp.267-278\nリファクタリングの方針\n 機能を小分けにして、各関数が1つの仕事のみに責任を持つようにするのが最善 設定用変数を1つの構造に押し込め、目的を明瞭化するのが最善 エラーメッセージで間違った情報をユーザーに与えないようにする エラー処理のコードを全て一か所にまとめ、将来エラー処理ロジックが変更になった時にメンテナンスで一か所のコードのみを考慮すればよいようにするのが最善  機能のこわけ バイナリプログラムの個別の責任を分割するためのガイドライン\n プログラムをmain.rsとlib.rsに分け、ロジックをlib.rsに移動する 解析ロジックが小規模な限り、main.rsにおいてもよい 解析ロジックが複雑化の様相を呈し始めたら、mainから抽出してlibに移動する  mainに残るのは呼び出し、他の設定、エラー処理であり、読めばその正当性を評価できるだけの小規模なもの。libにはロジック全てをおき、テスト可能にする。\n引数関数を抽出し、コマンドライン引数と変数がどう対応するかを決定する責任をmainから剥がす。\n設定用変数を構造体に押し込める 正しい抽象化がまだできていない兆候:\n タプルを返して、即座にタプルを分解し、再度個別の値にしている。 2つの値の関数がタプルにまとめていること以外、データの構造に、その意味を載せていない。  そこで、構造体に置き換え、構造体とフィールドそれぞれに意味のある名前をつける (Configという名前、それぞれのフィールド名、それで、フィールド名同士の関連を明らかにし、また、構造体名でプログラムの振る舞いを設定することという目的を明確に伝えられる。)\n文字列スライスではなく、Cloneを使って、Stringをフィールドに持たせる。 Cloneは価値ある代償である。\n 非効率さ  総コピーが生成されるので、文字列データへの参照を保持するよりも時間とメモリを消費する  RustaceanはCloneを避けるが、サイズや回数によっては、とりあえず使ってもよい  もっとRustの経験を積んでから考えろ       単純さ  参照のライフタイムを管理する必要がない。    構造体のimplに変える parse関数の目的が、Configインスタンスを生成することであるから、Config構造体にimplブロックで紐づくnew関数に移すことで、1つのリファクタリングができる。\nエラー処理の修正 添え字アクセスする前に、スライスが十分長いことを実証するチェックを追加し、それをResult型で処理する。\n チェックに失敗したら、panic!マクロを呼び出す案。  panic!の呼び出しはユーザーに与えたくない追加の情報を含んでしまう。 panic!の呼び出しは仕様の問題よりもプログラム上の問題により適している   Result型を返すようにする  panic!を呼び出す代わりにErr値を返し、  ユーザー向けのより実用的なエラーに変換することができる   Config戻り値をOkに包んで返す   Result型を処理する  unwrap_or_else(|err| {...}) Okならunwrapして Errならクロージャー内でコードを呼び出す  クロージャーは自ら定義して引数として渡す匿名関数     process::exit(n):  プログラムを即座に停止し、渡された数字を終了コードとして返す 0以外の終了コードは、我々のプログラムを呼び出したプロセスにプログラムがエラー状態で終了したことを知らせる慣習    プログラムのロジックの抽出 セットアップやエラー処理に関わらない部分の全てを保持するrun関数へ抽出\nResult\u0026lt;(), Box\u0026lt;Error\u0026gt;\u0026gt;を返すようにする\n Ok(())でユニット型の値をOk値に包む  runを副作用のためだけに呼び出していると示唆する慣習でもある   Box\u0026lt;Error\u0026gt;はトレイトオブジェクト  関数がErrorトレイトを実装する型を意味し 具体的に型を指定しなくてもよい  異なる型のエラー値を返す柔軟性を得る     expectではなく?演算子を使うようにする  ?演算子は呼び出し元が処理できるように、失敗時に、現在の関数からエラーを返す。    返されるResultの処理で、エラーを検知することのみに興味があるのであれば、unwrap_or_elseではなくif letでErr値を返したかどうかを確認する。\nisabelle Concrete Semantics pp.175-178, pp.179-180\n最小のfixpointをcomu0ptueする方法と、その決定可能性の補題。\nrvarsの導入\nWhileの場合のLの実行可能な定義の確認。\nForward/Backward\n Forward Analysis: プログラムの最初から最後へと情報を伝播する Backward Analysis: プログラムの最後から最初へと情報を伝播する  この前後の捉え方の違いがわからない。    May/Must\n May Analysis: あるpathにおいて、与えられた性質が真かどうかチェックする Must Analysis: 全てのpathにおいて、与えられた性質が真かどうかチェックする  分類\n Definite Initialization: Forward Must  変数はそれが使用される前に、全てのpathにおいて、assignされていなければならない   Constant Propagation: Forward Must  変数はそれが使用される前に、全てのpathにおいて、何らかのconstantを持っていなければならない   Live Variable Analysis: Backward May  あるpathにおいて、ある変数があり、それが書き換えられる前に、使われているならば、変数はliveである    11章のDenotational Semanticsに突入。\nDenotational Semanticsは、あるsyntacitc constantに対して、その合成されたものの意味は、部分の意味を引数とする原始再帰的な関数として定義される\n avalやbvalはdenotational semanticsであるが、 Big_Stepはそうではない  WHILE b DO cは、WhileTrueにおいて、bとcの意味だけではなく、WHILE b DO cの意味に機能的に依存する    Denotational Semanticsのモチヴェーション:\n 証明は、  等式推論の単純で有効な証明原理と syntax上の構造に関する機能法とによって、   実行される  1on1 『ヤフーの1on1』を読み終えた。\n後半は、ヤフーはこういう会社で、だから1on1を重視して、こう活用している、と結構会社の文化紹介を強く感じる内容であった。 が、全体のまとめという側面もあり、文化紹介であっても、その文化と関連しているから1on1を導入して、うまく活用できている、ということが察せられた。\nこの本を読み直し、まとめることは非常に効果があると思う。 というのも、良い失敗経験がこの本には書かれており、どうすれば良い1on1ができるのかについてよく記述しているからである。\nしかしながら、少し興味が1on1から逸れてきていること、 この本を読んで、会社における1on1をよりよくするための制度がまだ足りていない、ということを自覚したこと、 これら2点から、腰を据えて、まとめるのはまだ先でいいかな、と思うようになった。\nあと、Team Geekのまとめの発表がまだ社内で終わっていないし、ネタを作成するのにまだ足りない感じがする。\nteam geek このまとめについては、スライド形式にして、YouTube Liveとかで発表するとちょうどいいかもしれない。\nnext to read 次に読むのはデボラ・ザック『SINGLE TASK 一点集中術』にしよう。\n"},{"ref":"https://2222-42.github.io/2020/12/12/20201212log/","title":"20201212log","section":"post","date":"2020.12.12","body":"体調が崩れていることに完全に自覚した。\ndiary health 夜眠れず、昼にたくさん寝てしまう。\nおかげで勉強が全くできていない。\nやること:\n デパスをちゃんと夜21時に摂取し、布団に入り、寝て、朝5時に起きるようにすること。 夜20時以降は、Discordに入らない "},{"ref":"https://2222-42.github.io/2020/12/11/20201211log/","title":"20201211log","section":"post","date":"2020.12.11","body":"昨日の体調不良からだいぶ回復した。\ndiary health 体調不良は十分に心の不調を生み出す。\nMcAfee マカフィーの歴史をYouTubeで見ていたが、やはりセキュリティ関係は裏社会的な雰囲気、もしくはマッチポンプさを感じる。\n人の不安を煽ったり、人の弱みを握ったり、と。\npray 咎を取り除き、罪を赦す神\nどうか、この世を罪から救うために、私をお使いください。\n今日の勉強 rust TRPL pp.263-267\n std::env::args  引数のどれかが不正なユニコードを含んでいたらパニックする   std::env::args_os  不正なユニコードを含む引数を受け付ける必要がある場合OsString値を生成するイテレーションを返す  OsStringはプラットフォームごとに異なり、String値に比べて取り扱いが煩雑      collectはよく確かに注釈が必要になる。多くの種類のコレクションを生成することができるので。\nargsでとられる引数の第一に、バイナリの名前が入っている。 実行時に呼び出された名前をプログラムに使わせてくれる。\nこれで、出力でき、アクセスできる、ここから保存する。\nファイルを扱うから、std::fs::Fileが必要。\nstd::io::prelude::*\n ファイル入出力を含む入出力処理をするので、有用な取柄とを色々含んでいる 一般的な初期化処理で特定の型や関数を自動的にスコープに導入するように、明示的にuseする  やること:\n ファイルへの可変なハンドルをとる。 ファイル読み込み後に中身を保持する変数を確保 ファイルハンドルに対して、read_to_stringを呼び出し、引数としてこの可変参照を渡す  いくつかの欠陥(これから直すこと):\n main関数が複数の責任を持っていること できうる限りのエラー処理を怠っていること "},{"ref":"https://2222-42.github.io/2020/12/10/20201210log/","title":"20201210log","section":"post","date":"2020.12.10","body":"体調が悪くて、寝込んでいた。\ndiary 寝込んでいた。\n何もできなかった。\n"},{"ref":"https://2222-42.github.io/2020/12/09/20201209log/","title":"20201209log","section":"post","date":"2020.12.09","body":"昨晩から体調がおかしくなって、遊び呆ける。\ndiary mahjang 昨晩は眠れなさそうだったからずっと雀魂をやっていた。\nexchange hdd HDDの交換をする。\n次はSSDをM.2に換装するのをやりたい。\nlog メンクリに行く。\ngame 昨晩の寝不足のせいで、大して何かができるような状況ではないので、ゲーセンで遊ぶ。\nゲームというのは、それを一緒に楽しむ相手や、後で話す相手がいないと、全く面白さを感じられない。\n今日の勉強 rust TRPL pp.258-263\ntestsディレクトリの体系化、グループ化をする\n testsディレクトリ直下の各ファイルは個別のクレートとしてコンパイルされる  個別のスコープを生成するのに役立つ srcファイルとは同じ振る舞いを共有しないことを意味する   共通モジュールとして抽出しようとするなら、tests/module_name/mod.rs  モジュールの命名規則  (7章に書いてあるとあったが、本当だろうか？記憶にない)   これで結合テストファイルとして扱わないようにコンパイラに指示する 結合テストファイルからもモジュールとして使用することができる  mod module_name;と、モジュールを宣言      インポートできるものできないもの\n バイナリクレートのファイルで定義された関数をテストでインポートはできない  バイナリクレートはそれ単体で実行することを意味する   ライブラリクレートのみが、他のクレートが呼び出して使用できる関数を晒せる  ライブラリにロジックを置いて、 それをバイナリが呼び出す単純な構造    12章\nRustはコマンドラインツールを作るのにふさわしい言語であると言える、それは以下の特徴による\n 速度 安全性 単バイナリ出力 クロスプラットフォームサポート  grepを作る\n 環境変数の値を読み取ってツールの振る舞いを設定 stdoutの代わりに、標準エラーに出力(stderr)  エラーメッセージは画面上で確認しつつ、成功した出力はファイルにリダイレクトできる   これまで学んだ概念をまとめ、これ以降のを少し学ぶ  最初の仕事; 2つの引数を受け付けるようにする\n cargo newで生成されたプログラムは与えた引数を処理できない。  Crates.ioに存在する既存のライブラリもあるが、 この能力を自分で実装しよう   標準ライブラリで提供されている関数std::env::argsを使う  コマンドライン引数の値を読み取れるようにする コマンドライン引数のイテレーターを返す  イテレーターに関して知っておくこととしては、  一連の値を生成すること collect関数を呼び出し、イテレーターが生成する要素の値全部を含むベクタなどのコレクションに変えられること     useしてスコープを導入する時は、use std::envが慣習的  希望の関数が2モジュール以上ネストされている場合は、親モジュールをスコープに導入するのが因習的 use std::env::argsにして、argsだけで使用すると、現在のモジュールで定義されている関数と間違われやすくなるから     "},{"ref":"https://2222-42.github.io/2020/12/08/20201208log/","title":"20201208log","section":"post","date":"2020.12.08","body":"集中できない、テンションが上がらない、うまく心を操れない。\ndiary concentration うまく心を操れない感じがする。\nこれまで一連のタスクを並行してやっていて、1つのPRを立てたら、別のISSUEに取り掛かることができていたが、うまく切り替えられていたはずなのだが、ここにきて少し無理を感じている。\nそれは、キャパシティを超えたのか、それとも、一時的に集中できないのか、どちらだろうか。\n今日の勉強 rust TRPL pp.256-258\n結合テスト\n目的:\n ライブラリの色々な部分が共同で正常に動作しているかテストすること  手法:\n srcディレクトリと同じ階層にtestsディレクトリを作成する  Cargoはこのディレクトリに結合テストのファイルを探すことを把握している Cargoはtestsディレクトリを特別に扱い、cargo testを走らせたときにのみこのディレクトリのファイルをコンパイルする  #[cfg(test)]での注釈は不要     extern crate ...と追加する必要がある  testsディレクトリのテストはそれぞれ個別のクレートであるため、各々ライブラリをインポートする必要がある   特定の結合テスト関数を走らせたい、結合テストファイルにあるテストをすべて走らせたいなら、cargo test --test ファイル名  テスト結果は、単体テスト、結合テスト、ドックテストのをそれぞれ含んでおり、それぞれの結果が出力される。\n結合テストファイルはそれぞれ独自の区域があるため、testsディレクトリにさらにファイルを追加すれば結合テストの区域が増える。\n"},{"ref":"https://2222-42.github.io/2020/12/07/20201207log/","title":"20201207log","section":"post","date":"2020.12.07","body":"寝坊。6時半起床。人生について日中は考えない日だった。\ndiary work 寝坊したので、勉強が少ししかできなかった。\nリモートワークのいいところとしては、出勤時間ギリギリまで自分の勉強ができることである。\nフレックスなので本来出勤時間は厳密でなくともいいのだが、自分の体調をコントロールするためには、自分の日程をコントロールすることは良い手段であるから、そこは厳密に運用している。\nstop, look back and feed back 立ち止まり、振り返り、そして自己に対するフィードバックを行うというのを、今日は意識的にできた。\n仕事をしていると集中してしまい、どうしても、忙しさに甘えてしまう。\nおかげで過度に詰まりすぎず、過度に疲れず、適度に進捗を出すことができた。\n明日も、立ち止まり、振り返り、フィードバックするというのを短い時間で行えたらいいなと思う。\n(これを短期的なゴールと見なすのもありであろう)\npardon 赦しは得られているのか、という問題がある。\nそれの原理はキリストの死に至るまでの神に対する真っすぐさに対して、神が嘉とされたことで、神の前における罪という無限大のものが、許されるにあたったのである。\nしかし、そのキリストに私がどう繋がっているか、という問題がある。 これを使徒パウロは信仰によってと語っていた。\n神の前における罪の意識がないから、自分が何をするべきなのか、どういう人物になるべきかが分からず、信仰の実感を抱けていないのではないだろうか？ ただ、神が共にいるから、とキリストにあぐらをかいているのではなかろうか？　(ふと思ったが、自分の罪の意識が深い人ほど他者を罰する傾向にないだろうか？私は他者に対して、とりあえず100点を与えてしまうような人間である。)\nアイデンティティを、神の捉え方、そして、神とつながるところのキリストとどう私がつながっているかを考えねばならない。\n今日の勉強 rust TRPL pp.240-254\nRustコミュニティにおけるテストの2つの大きなカテゴリー\n 単体テスト  個別に1回1モジュールをテスト 非公開のインターフェースもテストできる   結合テスト  1テストで複数のモジュールを用いることもある 完全にライブラリ外になる  公開インターフェースのみ使用できる      テストは、ライブラリの一部が個別かつ共同でしてほしいことをいしてることを確認するのに重要\n単体テストの目的:\n 各単位のコードを、残りのコードから切り離して、 コードが想定通りにに、動く箇所・動かない箇所を 迅速に特定すること  単体テストの慣習:\n 各ファイルにtestsという名前のモジュールを作り、 テスト関数を含ませ、  結合テストは別ディレクトリに存在するので、以下の注釈は不要   モジュールにcfg(test)と注釈をつける  cfgはconfigurationで、コンパイラに続く要素が、ある特定の設定オプションを与えられたら、このモジュールを含めるように指示する cargo testを走らせたときにだけ、テストコードをコンパイルし走らせるよう指示  モジュールに含まれるかもしれないヘルパ関数もコンパイル対象に含まれる   通常のビルドでのコンパイル結果に含まれないように指示をする テストコードもコードで、testsモジュールもモジュールであるから、非公開関数を呼び出せるのでそれのテストをできる。   "},{"ref":"https://2222-42.github.io/2020/12/06/20201206log/","title":"20201206log","section":"post","date":"2020.12.06","body":"日曜日、午前中は、Rustの勉強と、日曜礼拝、そして、自分のミッションを見つめ直す時間を設けた。\n午後はIsabelleを少ししたら、会社からの連絡があったので、諸々の準備をし、出社し、労働。日課が崩れた。\ndiary church FEBCで日曜礼拝を聴く。\nパウロが圧迫を感じ、絶望を覚え、そして心を合わせた共同の祈りを求めた話。\n困難に直面し、神の救いを得、困難に直面し、神の救いを得、これがずっと続く。 神のみ心に沿い、救いの働きの完成に至り、御国の到来がくる。 けれど、困難が直面し続ければ、パウロですら、希望を失ってしまう。\n祈りというのは呪術ではない。 御心に沿うように神に身を委ねることである。\n「アーメン」と、賛同の言葉を口から出すことによって、1人の人の祈りを共同の祈りとするのである。\n神のみ心に沿えるように、どうかお導きください。\nアーメン\nmovie ５分の休憩で見続けていた「Fight Club」をとうとう見終えた。\n最後、なんでタイラーは「なんだこの匂いは？」と言ったのだろうか？\nvision 自分のミッションを見つめ直す。\n20201126logに書いてあったことの修正\n CoreValue  チームの基礎的な信念   Purpose  チームの存在理由 チームの組織への影響力   Mission  達成しようとしている目的   Strategy  ミッション達成のために将来にわたって天下宇する手段   Goal  ストラテジーを短期的で達成可能な目標へ落とし込んだもの     「私の基礎的な信念は何か」  人との交わり・関わり、及びその場は重要であり、そこにおける発言や活動は、いずれその人、その場、社会へと影響を及ぼすという信念 情報や技術は、個人の問題および人間関係の問題を改善・解決に導くという信念。 真理と愛とは世界に光をもたらす。  真理、特に、定理は、不確かな世の中において、確かなものである。     「私の存在する理由とは何か」「私の社会、世界への影響力とはどれほどのものか」  もちろん、この世を罪から救うという目的はある。  隣人の必要に焦点を合わせ、貢献をするため。   キリストの真理と愛とを実現するため。   「私が達成しようとしている目的はなんだろうか」「どういう人物像になりたいのだろうか」  キリスト者であり、キリストの真理と愛を実現すること。   「長期的に、目的のために、なりたい人物像のために、どういうことをやっていくのがよいか」  愛、喜び、平和、寛容、親切、善意、誠実、柔和、節制、これらを身につける 知恵と分別を身につける。   「今年一年など短期的に、どういう風に成果を出せるだろうか」  規則正しい生活を送る 言うに遅く、聞くに早く、怒るに遅い、そんな人    もうちょっと技術に近いことを語りたい。 技術よりの方は、今回のとは異なり、技術よりの方として、別の体系を作った方がいいかもしれない。\n20201204logから神の捉え方の再録\n 「神は、全知全能であり、間違いがなく、クリアで、ご計画を持っており、また慈悲に満ち、そして、善悪ではなく神の前のまっすぐさをご提示される方。」\n「欠けており、穢れに満ちている私に、神は、常に寄り添い、共に歩んでくださる方。」\n 20201018logより、\n 信仰は望んでいる事柄を確信し、見えない事実を確認すること。つまり、神の存在や神の愛を確認できる。\n行いが伴わないなら、信仰はそれだけでは死んだもの。信仰という心から神へ愛を伝えるチャネルを成長させるためには、行い・活動が必要である。信仰が愛を導き、行動がその愛の実現を導く。 御言葉を読み、神が私達の魂に入り込む様を見、祈るという行動こそが、神様に愛を本物で成熟したものへと涵養する。\n work なんと日曜日なのに会社から連絡があり、労働をする。\n出社すると決めてから、準備に一時間をかける。なぜならこれを怠ると、仕事モードに切り替わらないからだ。\n運動をし、シャワーを浴び、髪を整え、Beard Oilで髭を整え、シャツを着、タイをしめ、タイピンをして、スーツを着て、髭を整え、財布とキーケースを右ポケットと左ポケットにいれ、ペンを２本とメモ帳を左胸内ポケットに入れ、タイと合わせた色のハンカチを右外ポケットに入れ、左後ろポケットと左外ポケットにスヌースを入れる。 この一連の作業なしに、切り替えることはできない。\nさて、会社の問題であるが、原因はよくわからないけれどルーターの設定がくるっていたので、初期設定からやり直した。 一番大変だったのは、複合機との接続だった。 もう二度とやりたくない。\nあと、代表が会社の説明文書で苦労していたので、相談を受けた。 結局、彼には語るだけの十分な素材があったのであるが、それの整理や分類、体系化ができていなかった。 そのため、本日のweblogでも述べた、CoreValueとPurpose、そしてMissionの三つについて説明し、彼の言葉を文書化、分類、それらの関連付けを行った。\nすでにあるものを並べただけであり、方向性を私は与えた。 あとの体系化や一連のまとまりのある文章とするのは彼の仕事である。\nまた、聴く際の技術としては、1on1で学んだことをいくつか採用してみた。 話を引き出すこと、相手に深く考えさせるところ、次への課題の設定をすることができた。\n今日の勉強 rust TRPL pp.240-254\nカスタムメッセージを失敗メッセージと表示できる。\n 必須引数の後に指定された引数は全てformat!マクロに渡される  {}プレースホルダーを含むフォーマット文字列と このプレースホルダーに置き換えられる値を渡すことができる   アサーションがどんな意味を持つかドキュメント化するのに役立つ  失敗したアサーションがどの行にあるかに加え、どのような値で失敗したかがわかる  要件が定まりきれていない場合は、正確な等値性を確認するのではなく、含むかどうかをアサーションする。      should_panic属性\n パニックしたらテストを通過させる 想定通りにコードがエラー状態を扱っていることを確認できる #[test]属性の後、適用するテスト関数の前に、#[should_panic]属性を配置 正確を期すために、should_panic属性にexpected引数を追加することができる  起きると想定していたもの以外の理由でテストがパニックして通ってしまうので、不正確なこともある。 これで、メッセージの一部もしくは全体が含まれているかテストできる  予想される文字列を含んでいなければ落ちる   引数の指定の仕方は、パニックメッセージの固有な箇所、動的な箇所、テストをどの程度正確に行いたいかによる    Result\u0026lt;T,E\u0026gt;を使うテストもある\n 例えば、assert_eq!マクロを呼び出す代わりに  成功すればOk(())を 失敗すればErrにStringを入れて返す   これだと、?演算子をテストの中で使える  テスト内で何らかの工程がErrヴァリアントを返したい時に、失敗するべきテストを書くのに便利   #[should_panic]注釈は使えない  失敗しなければならないときには直接Err値を返せ    テストの実行の仕方を制御する。テストには、cargo testにあかるものと、出来上がったテストバイナリにかかるものがある。\n cargo testの規定動作  テストを全て  名前で指定したもののみ実行さえｓる  引数なしだったらすべて実行 引数にテストの名前をいれると、部分一致するもの全部一致するものについてのみ、テストを走らせることができる  モジュール名でフィルターがけすることもできる。     ignore属性で注釈して、テストから除外する  #[test]の後の除外したいテストに#[ignore]行を追加する  除外されたものはn ignoredに追加される   無視されるテストのみ実行したかったら、cargo test -- --ignored     並行に実行し、  並行に実行するのは、早く実行し終わり、反応をより早く得られる 注意: 相互に共有された環境を含むほかの共通の状態に依存していないことが求められる --test-threads=n  使用したいスレッド数をテストバイナリに送れる 有用な場面  1に設定して、並行性をしないようにして、状態を共有していてもお互いに邪魔しないようにする際 使用するスレッド数をよりきめ細かく制御したい場合       テスト実行中に生成された出力をキャプチャして出力が表示されるのを防ぎ、テスト結果に関係する出力を読みやすくする  テストが失敗した場合、残りの失敗メッセージとともに、標準出力されたものが全て見える テストが成功した場合は、テストが通ったことを示す行しかみられない  --nocaptureフラグで、出力キャプチャ機能を無効化し、パスするテストについても標準出力される値が見れる        isabelle Concrete Semantics pp.174-175\nLive_trueの定義を理解。 だいたいにおいて、数学の定義や定理を理解するためには、思いつく人の思考のトラッキングが必要である。 しかし、やはり思考をトラッキングできていない。十分に頭脳を発揮できていない。 (そもそも、十分に頭脳を発揮できたことが、私にこれまで一度でもあったであろうか？)\nまた、Lが正しいことの証明を読み終えた。 結局、前のLiveのと一緒の証明で、あとはLについての形式を整えるだけだった。\n1on1 1on1のアクティブリスニングの技術を身につけるのはかなり骨を折るだろうな、と思いながら読み進める\n"},{"ref":"https://2222-42.github.io/2020/12/05/20201205log/","title":"20201205log","section":"post","date":"2020.12.05","body":"寝坊したが、すっきりした一日を送れた。\ndiary oversleep 午前11時に起床と、だいぶ寝坊をした。\n一つはデパスとかゆみ止めで眠気がすごいことになっていたのだろう。\nそしてもう一つは、久しぶりに実施した、きつめの筋トレが原因だろう。\nhealth 睡眠と筋トレのおかげか、かなりすっきりした一日を送れた。\nステロイドとかゆみ止めのおかげで手指の荒れがだいぶ落ち着いてきている。が、まだ皮が薄いような気がする。\npray どうか今日のように実り豊かな一日を送れるように、主よ、どうかお導きください。\n弱いところに流れようとする私を支えてください。\n喜び、祈り、感謝し、 霊の火を消さず、預言を軽んじず、 全てのものを吟味し良いものを大事にし、 あらゆる悪いものから遠ざかります。\n日々の生活をより豊かにするために、どうか、定期的にしっかりと運動させて下さい。\n今日の勉強 rust TRPL pp.228-240\n11章のテストの話\nテスト関数の本体の典型的な３つの動作\n 必要なデータや状態をセットアップ テスト対象のコードを走らせる 結果が想定通りであることを断定(アサーション)する  Rustにおけるテスト\n test 属性で注釈された関数  属性とは、Rustコード欠片に関するメタデータのこと   fnの前に#[test]を付け加えたもの  この注釈がテスト関数であることを示 テスト実行機はこの関数をテストとして扱うとわかる   testモジュール内には、  テスト関数以外の関数を入れられ、  シナリオのセットアップをしたり、共通の処理を行う手助けをしたりもできる。   テストだったら#[test]注釈を付けることで、どれがテストする関数かを示す必要がある。   各テストは新規スレッドで実行され、テストスレッドが淫だと確認したとき、メインスレッドがテストはFAILEDと印づける コンパイラはAPIドキュメントに現れるどんなコード例もコンパイルでき、ドキュメントとコードを同期することができる コードに変更を加え、バグを導入したらテスト結果が失敗したら、テストによりバグが補足されたことになる  Compiling Finished Running test tests::(テストする関数の名前) ... (実行結果) test tests::(テストする関数の名前) ... (実行結果) (失敗していた場合は、 失敗している各々の関数の失敗理由と 失敗した関数一覧 の2つのフィールドあ出力される) test result:(総合結果) (成功数、失敗数、無視すると指定したテスト数、ベンチマークテスト用、実行するテストのフィルターがけした数) (テストが通ったら、ドキュメンテーションテストの結果が出力) assert!マクロ\n テスト内の何らかの条件がtrueと評価されることを確かめたい時に有用 論理値に評価される引数を与える  trueなら何もせずにテストは通り falseならpanic!マクロが呼び出されテストは失敗    testモジュールは、\n 通常の公開ルールに従う普通のモジュールであり、  内部モジュールなので、 外部モジュール内のテスト配下にあるコードを、 内部モジュールのスコープに持っていく必要がある    assert_eq!マクロとassert_ne!マクロ\n アサーションが失敗したら、2つの値を出力することもするので、これにより、テストが失敗した原因を確認しやすくなる  失敗したら、2つの引数をleftとrightと表示する  Rustでは、expectedとactualのような順序の問題はない     assert_eq!マクロ  テスト下にあるコードの結果をコードが返すと期待される値と比較して、等しいと確かめるために有用   assert_ne!マクロ  値が何になるであろうか確信が持てないけれども、コードが意図したとおりに動いていれば確実にこの値にはならないとわかっているような場合に有用   これらのマクロを使うためには、PartialEqトレイトとDebugトレイトを実装していなければならない  ==と!=演算子を使用しているからPartialEq デバッグフォーマットを使用してプリントしているのでDebug これらを実装するには、単純に構造体やenum定義に#[derive(PartialEq,Debug)]と注釈を追加すればよい。    1on1 『ヤフーの1on1』は結構面白い本であると感じた。\n現在5分の3ほど読んだ。読み終えたら、再度読んで、メモを作ろうと思う。\nisabelle Concrete Semantics pp. 172-174\nKnaster-Tarski fixpoint theoremを読む。 単調性だけえ、最小のpre-fixointを導きだせるので、すごい性質だと思う。 これで、変数のLiveをちゃんと記述できることの確証に繋がる。\n証明や定義を読んでいて、思ったが、圧倒的に証明力が落ちていると感じた。\n"},{"ref":"https://2222-42.github.io/2020/12/04/20201204log/","title":"20201204log","section":"post","date":"2020.12.04","body":"健康診断。メモリ増設。アイデンティティは神の捉え方との反復。TRPL10章を終えた。\ndiary annual medical check up 年に一度の健康診断を行った。\n採血した後の食事は肉を取りたくなるし性欲が高まる。\n伸長と体重はそれほど変わっていなかった。その場でわかるものとしては、それほど変化は見られなかった。\nとりあえず検査が終わったら、速攻でコーヒーとLチロシンとビタミン剤を摂取した。\npc メモリを増設した。\n16GBから32GBなので、Stationを起動しても、全然困らない。\nhow to be positive 特攻兵のようなネガティブな気持ちでの活動ではなく、十字軍のような、もしくはイラク戦争のアメリカ軍のように、目標に向かって、ポジティブに活動できるためにはどうするべきなのか。\n結局のところは、自分が何者であるか、また、その集団がどういう特性を持っているかを理解して、 それを刺激できることによって、あの振る舞いは成し遂げられるのであろう。 (もちろん、集団の特性を刺激できたとしても、それより大きな集団の特性と相反していたり、もしくは、自分のアイデンティティを崩壊させたり、ということは起こる)\nwho I am 「神は誰か」と「私は誰か」という2つの問いはつながりを持っている。\n神は不変であるが、神をどう捉えるか・信じるかにより、自分のアイデンティティは変わる。\n父なる神よ、あなたは私をどういう目的でこの世にもうけられたのでしょうか。\n「神は、全知全能であり、間違いがなく、クリアで、ご計画を持っており、また慈悲に満ち、そして、善悪ではなく神の前のまっすぐさをご提示される方。」\nこのように書くと、自分の欠けているところを明瞭になる。\n「欠けており、穢れに満ちている私に、神は、常に寄り添い、共に歩んでくださる方。」\nこう書くと、キリストを常に胸に抱き、御子がお出でになるその日に、備えなければならない、という気持ちになる。\nそうか、私は、自分と同じように、この世において、困っている人の傍に寄り添い、共に歩むことを望んでいるのか。\nいや、これではただの私の大きな目指すべき特徴である。\n もっと私が神をどう捉えているか明確にして、もっと私の深いところを捉え、私が何者であり、どのような目標を持っているかを明らかにしなければならない。 20201126logで書いている、チームのビジョン設定に、上記のをあてはめて考えてみる。 そして、自分のなるべきクリアなビジョン、つまり、人生におけるMissionを抱く。  そのために聖書を毎日読もう。\n今日の勉強 rust TRPL pp.225-227\n10章のまとめ\nコードを書く量を減らせるようになった\n ジェネリックな型引数で  コードを異なる型に適用できる   トレイトとトレイト境界で  型がジェネリックであっても コードが必要とする振る舞いを持つことを保証する   ライフタイム注釈で  この柔軟なコードにタングリング参照が存在しないことを保証    これらの解析はコンパイル時に起こり、実行時のパフォーマンスに影響しない\n11章\n プログラムの正当性は、どこまで自分のコードが意図していることを行っているか、である  コンパイラはプログラマの意図を確かめられない   正当性は複雑  単純に証明することはできない 型システムは多くの部分を肩代わりしてくれる  しかし、あらゆるシュルの不当性を把握してはくれない     Rustは自動化されたソフトウェアテストを書くことをサポートしている  アサーションをするようなテストが書ける  これによって、コード変更の際の既存の正当な振る舞いが変わっていないか確認できる。     テストは複雑なスキル  なので、11章では、Rustのテスト機構のメカニズムについて議論する   "},{"ref":"https://2222-42.github.io/2020/12/03/20201203log/","title":"20201203log","section":"post","date":"2020.12.03","body":"特になし。疲れている。今日は朝勉強もできなかった。\n健康診断のせいで、ビタミン剤とチロシンを取れないからだ。\n"},{"ref":"https://2222-42.github.io/2020/12/02/20201202log/","title":"20201202log","section":"post","date":"2020.12.02","body":"今日は皮膚科に行ったり\ndiary game 昨晩はゴッドフィールドをプレイしていた。ルールを大凡把握できた。\nAPEXをインストールした。チュートリアルを終えた。\ndermatology 午前中に皮膚科に行った。\nステロイド治療をすることになった。かなり即効性がある。\nlong nap 五時間昼寝していた。\nmercari ウェブポンでダブった製品をメルカリに出品。\nそのコラボ相手の人気はそれほど高くないので、売れる見込みは少ないが、 市場価値としてこうあってほしい金額で出しておく。\nウェブポンの場合、転売という表現はあまり該当しない。ああいった謎の景品の場合、こうでもしないと価値が定まらない。\nあと、反応を見ていると、コラボ相手のファン層がメルカリとか転売とかにすごく嫌な感情を抱き、それが先行し過ぎている人がちらほら見えた。 それはその層特有ではなく、広くそういうものなのかもしれない。 (ファン心理として認められないものを売ることがあるのは確か。例えばサイン色紙とか。)\nそういった反応を頭が悪いというつもりはないし、転売は良い行為だと両手を上げるわけでもない。 ただ、市場に出回る機会すらないようなコラボ商品という物の価値はとてつもなく低いか、とてつもなく高いかで、つまり値段が付けられないものであり、結局、そのコラボ相手の価値を測れないものであることを示してしまう。\n今日の勉強 rust TRPL pp.216-225\n関数のライフタイム注釈の書き方\nfn function_name \u0026lt;\u0026#39;a\u0026gt; (x: \u0026amp;\u0026#39;a t, y: \u0026amp;\u0026#39;a t) -\u0026gt; \u0026amp;\u0026#39;a t { ... } コンパイラに型注釈が教えること:\n 何らかのライフタイム'aに対して  その引数は少なくともライフタイム'aと同じだけ生きること その返り値もまた少なくともライフタイム'aと同じだけ生きること  引数のうち小さいほうに等しい具体的なライフタイムになる      いかなる値のライフタイムも変更していない。 むしろ借用チェッカーはこれらの制約を守らない値をすべて拒否するべきと指定。 引数のうち小さいほうに等しい具体的なライフタイムになるので、無効になる可能性があるので、その場合は拒否する。\n関数は正確な生存期間を知る必要はなく、何らかのスコープが'aに代替され、このシグニチャを満足することだけを知っている必要がある。\n手動でライフタイム注釈をする必要がある理由\n  注釈は関数シグニチャに嵌り、関数本体には嵌らない\n  コンパイラは、\n 関数内のコードを解析できる一方で、 外から持ち込まれた参照や外へ持ち出される参照がある場合、それだけの情報でライフタイムを解決することはほぼ不可能  例外としてライフタイム省略規則があり、解決できる      ライフタイム引数を指定する必要のある手段は関数が行っていることによる\n  関数が参照を返す際、戻り値のライフタイム引数は、引数のうち、どれかのライフタイム引数と一致する必要がある\n そうでなければ、関数内で生成された値への参照であり、それは末端のスコープで抜け、片づけられ、タングリング参照をうむ  その場合は所有されたデータ型を返せ      究極的にライフタイム記法は、関数の色々な引数と戻り値のライフタイムと接続することに関する\n 繋がりができたら  メモリ安全な処理を許可するのに十分な情報がコンパイラにはあり メモリ安全性を損なうタングリングポインタを生成するであろう処理を不認可する      構造体にライフタイム 構造体に参照を保持させるには、ライフタイム注釈をつける必要がある\nstruct StructName \u0026lt;\u0026#39;a\u0026gt; { field: \u0026amp;\u0026#39;a t } この注釈は、StructNameのインスタンスがフィールドに保持している参照よりも長生きしないことを意味する。\nライフタイム省略規則 ライフタイム注釈なしでコンパイルできるケースは歴史的な経緯による\n 開発者が予測可能で決定的なパターンをコンパイラのコードに落とし込んで 借用チェッカーがライフタイムを推論できるようになり、明示的な注釈を必要としなくなった。  ライフタイム省略規則:\n コンパイラの参照解析に落とし込まれたパターンのこと  コンパイラが考慮する一連の特定のケース   完全な推論を提供しない  曖昧性があるなら推論するのではなくエラーを与える    用語:\n 引数のライフタイムを「入力ライフタイム」といい 戻り値のライフタイムを「出力ライフタイム」という  ３つの規則。上から順に適用される。\n 参照である各引数は、独自のライフタイム引数を得る 1つだけ入力ライフタイム引数があるなら、そのライフタイムを全ての出力ライフタイム引数に代入する 複数の入力ライフタイム引数があるが、メソッドなのでそのうち一つが\u0026amp; self や\u0026amp;mut selfなので、selfのライフタイムが全出力ライフタイム引数に代入される  メソッドシグニチャのライフタイム引数 ジェネリックな型引数の場合と同じ記法\nimpl \u0026lt;\u0026#39;a\u0026gt; StructName \u0026lt;\u0026#39;a\u0026gt; { ... }  参照が構造体のフィールドの参照のライフタイムに紐づくか独立しているかの可能性があること 省略規則でライフタイム注釈が必要なくなることがよくあること  \u0026lsquo;static  特殊なライフタイム 'staticは、プログラム全体の期間を指す。  例えば、文字列リテラルは全てこれ  なぜなら、プログラムのバイナリに直接格納され、常に利用可能だから。      注意: エラーメッセージで'staticライフタイムの仕様を提言されても、本当に全期間生きてほしいかどうかを考慮せよ\nなぜならほとんどの場合、その問題は以下のいずれかである。\n タングリング参照を生成しているか 利用可能なライフタイムが不一致しているか "},{"ref":"https://2222-42.github.io/2020/12/01/20201201log/","title":"20201201log","section":"post","date":"2020.12.01","body":"新たなディスプレイの到着と、その感想。\ndiary display U3415Wが届いた。\n でかい  設置と配置でかなり苦労した  重い 他のディスプレイとの配置で悩む   箱の置き場所で悩んでいる。    曲面で、ウルトラワイドモニターなので、視点の動かし方が結構楽だ。\nデイジーチェーンを初めて使ってみた。 コードの長さが足りないことから、outがあることから、調べてみたらヒットした。 これまでの物理コードの管理よりも、これで多少楽になった\n今日の勉強 rust TRPL pp.214-216\n 複数の参照を引数にとる関数で、その引数のうち1つを戻り値として返すような関数を考える。  そして、返される参照がいずれを参照しているかがコンパイラにはわからない。 つまり、引数のライフタイムが戻り値のライフタイムとどう関係しているかわからない。  そして、参照間の関係を定義するジェネリックなライフタイム引数を追加しなければならない     ライフタイム注釈  ジェネリックなライフタイム引数の指定  あらゆるライフタイムの参照を受け入れる ジェネリックな型引数があらゆる型を受け入れるのと同様   ライフタイムに影響を与えることなく、複数の参照のライフタイムのお互いの関係を記述する、そして、どう関係しているかをコンパイラに指定する 記法  アポストロフィーではじめ 通常全部小文字で 短い名前で 注釈は参照の\u0026amp;の後に配置 注釈と参照の型とを区別するために、その間に空白を1つ     "},{"ref":"https://2222-42.github.io/2020/11/30/20201130log/","title":"20201130log","section":"post","date":"2020.11.30","body":"寝坊しても、どこかの時間で絶対に少しだけでも勉強するぞ、という強い気持ちをもって活動する。\ndiary morning 寝坊したので、朝勉強できなかった。夜８時から３０分だけ時間をとることにした。\nstomach 昨日、8ピースもKFCを食べてしまったからか、お腹の調子が悪い。\nこうやって年齢をどんどん感じるようになってきている。\nteam 代表と一緒に、会社の方向性やチームの方向性についてざっくりおしゃべりする。\n 前は、駅前のあの建物の名前をうちの社名に変えてやる！みたいな面白い目標を語っていたのに、最近は語っていないからおもしろくない、とか(こういった中短期の面白い目標を語れると相手にも伝えやすい)。 チームの目標の明確化をしておかないと、みんなの成長を促せないよね、どうしようか、という話とか。  内側に示すところと 外側に紹介するところ    会社とか事業とかチームとかの話をその場の課題意識から語れるのはいいところ。\npray どうか、燭台の上に置かせてください。 人々を照らすように私を働かせてください。 主よ、どうかお導きください。\nengineering エンジニアに求められる基本的なコミュニケーション能力というのはおおよそ以下の３つであろう。\n 問題の構造化からやることの細分化と、 やりたいことの明確化と、 その場での相手の悩みを和らげるための回答能力  これら3つを揃えていたら、多分技術力を発揮できる土台があるのだろう (私は技術力がなくて悩んでいる。結局、何をもって生きていくかというキャリアデザインをどこまで明確化できるかで悩んでいる。)\nそれでもなお、私はこれらが自分でできているという自信がない。\n構造化や明確化ができておらず、第三者に自分の視点ではないものから、自分の見解について、すぐにフィードバックが得られるようにするよう心掛けている。\nまた、本当に相手の痛みを和らげようと努力しているか、もっと相手の声に耳を傾けられているか、もっと悩みのディティールを細かくするためにお話を深く掘り下げられないか、それらをおろそかにしていないだろうか、と私は自分に疑っている。そして、相手の立場にたって、相手の痛みを和らげようとする振舞いが、ちゃんと発揮されていないと思う。\n今日の勉強 rust TRPL pp.212-214\n コンパイラがライフタイムを解析して、参照が常に有効であることを保証する仕組みがある。  タングリング参照が起きるケースとして、参照している値を使おうとする前にその値がスコープを抜けるとコンパイルできない。  その時のメッセージは\u0026quot;does not live long enough\u0026rdquo; スコープが大きいことを「長生きする」と言うことがある     借用チェッカーがやること:  スコープを比較して、  変数それぞれのライフタイムブロックをとり、 その長さを比較する   全ての借用が有効であるか確認する  一方が他方のメモリを参照していて、参照の対象が参照ほど長生きしているか確認する     借用チェッカーにより、コンパイラが参照が有効であることを把握することで、変数は参照をすることができる "},{"ref":"https://2222-42.github.io/2020/11/29/20201129log/","title":"20201129log","section":"post","date":"2020.11.29","body":"休日を謳歌するという挑戦をした。革の手入れ、肉、映画。しかし、渇きは収まらない。\ndiary 趣味 趣味がないので、何かを積み立てることを考える。\n前に、まとめて投げ売りされていた、財布の革の製品を掃除することにした。\n今日は２つの財布の汚れをとった。\n掃除したらメルカリでまとめて売ろうと思う。\nmeat and movie 肉を食べたいという欲が強くなり、ケンタッキー・フライド・チキンであのバケツを買った。\nそして、Amazonプライムで映画を２本見た。\nなんというか、絵にかいたよな休日の過ごし方だな。 (恋人や友人が隣にいないのは残念だが)\nthirst しかし、渇きは収まらない。\n自分を見つめているというのは、渇きを覚えているからだ、満たされるということを覚えたい。\n水が欲しいのだ。永遠に渇きを覚えるのことのない水を。\n今日の勉強 rust TRPL pp.203-212\n トレイト境界構文 複数のトレイト境界を+構文で指定できる トレイト境界を関数シグニチャの後のWhere区の中で指定するという構文が用意されている impl Trait構文を戻り型のところで使い、そのトレイトを実装する何らかの型を返せる  一種類の型を返す場合にのみ使える  impl Trait構文の実装周りの制約による １７章で許容する方法を学ぶ     必要な型はエラーメッセージを見ればわかる  自力で調整するところとしては  Copy Traitを使うか、CloneTraitを使うか いずれも使わず、参照を返すことにするか     特定のトレイトを実装する型に多雨するメソッド実装を条件分けできる  別のトレイトを実装するあらゆる型に対するトレイト実装(ブランケット実装)ができる   トレイトとトレイト境界により  重複したコードを減らしつつ、 コンパイラに対し、ジェネリック中谷特定の振る舞いが欲しいことを指定するコードを書くことができ トレイト境界の情報を活用して、コンパイラは、コードに使用された具体的な型が正しいふるまいを提供しているかを確認できる。  実行時の振る舞いを確認するコードを書かなくともよい。      ライフタイム\n 「参照は全てライフタイムを保持する」 ライフタイムとは、その参照が有効になるスコープ  型と同様、ライフタイムも暗黙的に推論する  いくつかの異なる方法で関係しているとき、注釈する必要が生じる ジェネリックライフタイム引数を使用して、関係を注釈し、実行時に実際の参照が確かに有効であることを保証することを要求する     ライフタイムの主な目的は、タングリング参照を回避すること  タングリング参照が起きると、参照するつもりだったデータ以外のデータを参照してしまう   "},{"ref":"https://2222-42.github.io/2020/11/28/20201128log/","title":"20201128log","section":"post","date":"2020.11.28","body":"今日は安息の日とした。 自分の問題は、自分がどこにいるのかを捉えることであることだと思う。そして、自分の環境がどうであるかを見極めることである。\ndiary buy このコロナの情勢で、自宅における作業環境をよりよくするため、メモリとHDDの購入、そしてとうとうウルトラワイドモニターの購入をした。\nでかい出費であるが、痛みは少ない。 必要なものであるから。\nPCをあけてどうこうするのは面倒だが面白味がある。\nvision 全能の父なる神はアダムに「どこにいるのか」と問うた。\n今、私はどこにいるのだろうか。\nすべきことを見つける前に、私がどこにいるのかを見抜かねばならない。\n(あなたは常に私と共におり、どこに私が行こうとも、あなたの霊から離れることはできません。)\nVPoE インタビュー記事を読んだ。 あんまりすっきりしなかった。 というのも、経歴とか、内的理由とかの方が多く、あまり何をやっているか、どうやっているかについての深い説明がなかったからだ。 (そもそも他人に興味がないのではないだろうか、私は？)\nmy vision そのうえで、自分がやらねば、と思ったのは、やはり第一に内的理由の発見と、第二に組織に対する責務やインパクトを見つけることである。\n自分の内的理由の探求については、先日のチームのミッション作成の方法を個人のものに流用することを考えている。\nあそこで欠けていた視点は、今自分がどういう環境にいるのか、ということと、どう環境が変わっていくか、である。\n第二の課題については、小さな組織においては、大きなインパクトを出しづらいという問題はある。 ただ、見せ方をどうするか、というところは意識して損はないだろう。\n自分は何のために生まれ、そして、どこにいて、どうしてここにいて、なにをするのか、ということについて、把握しなければならない。\n今日の勉強 rust TRPL pp.197-203\n Traitを型に実装する。  imple Trait名 for 実装対象の型 {...} Traitで目的の動作を定義し、型にトレイトを実装 impl ブロック内に  目的のメソッドシグニチャを置き 欲しい特定の振る舞いをメソッド本体に入れる   作ったTraitは外部からuseを用いてスコープに取り込むことができる 注意すべき制限  トレイトか対象の型が自分のクレートに固有(local)であるときのみ、型に対してトレイトを実装できるというCoherence もしくは孤児のルールという制限がある  外部のトレイトを外部の型に対して実装はできない  他人のコードで破壊されたり、他人のコードを破壊したりが生じない         トレイトの全てあるいは一部のメソッドに対してデフォルトの振る舞いを指定できる  メソッドシグニチャを;で終えるのではなく、{}でメルコとで 対象の型で実装しなかった場合はそれを呼び出すようになる  デフォルト実装をオーバーライドするのは、通常の実装がそれ。 デフォルト実装をオーバーライドしている時相から呼び出すことはできない   デフォルト実装は、自らのトレイトのデフォルト実装を持たない他のメソッドを呼び出すことができる   トレイトを引数にすることで色々な種類の型を受け付ける関数を定義できる  引数の型に、具体的な型の代わりに、impl キーワード + トレイト名とする  これで指定されたトレイトを実装しているあらゆる型を受け付ける   この書き方は、より長いトレイト境界(trait bound)と呼ばれる姿の糖衣構文  fn 関数名 (引数: impl トレイト名) fn 関数名\u0026lt;型引数: トレイト名\u0026gt; (引数: 型引数)  トレイト境界を使った方が、複雑な状態を表現できる        team 痛い失敗例を全然書いていないから面白くなかった。\nこうやりましょう！みたいなのだけだと痛みがなく、心に響きも得られない。\nisabelle L_correctの証明をそのままbury_correctに流用した。\n"},{"ref":"https://2222-42.github.io/2020/11/27/20201127log/","title":"20201127log","section":"post","date":"2020.11.27","body":"ひどい一日だった。お酒に逃げた。\ndiary 想定通りに進まないことへのいらだちが感じられた。\nまた、ひどい虚無を覚えるときがあった。 そのため、早退した。\n酒に逃げた。ワイン(カベルナ)とラム肉。 悪くはなかったがアルコール欲しさにワインを飲んでいるような感じがして、よいものではなかった。\n葉巻を雑に吸う。 過っとが多少うまくなったような気がする。\n今日の勉強 rust TRPL pp.192-197\n ジェネリックな型を使うメソッド  impl\u0026lt;T\u0026gt; Name\u0026lt;T\u0026gt; {...} ジェネリックな型を使うのであれば、implの直後に型引数Tを宣言しなければならない  ジェネリックな型であることがわかる Name\u0026lt;T\u0026gt;にメソッドを実装していることを指定するために、Tを使用することができる。 impl Name\u0026lt;i32\u0026gt; {...}などと特定の型だけの実装の場合を書くこともできる   構造体定義のジェネリックな型引数は、必ずしもその構造体のメソッドシグニチャで使用するものと同じにはならない  一部のジェネリックな引数はimplで宣言され、他の一部はメソッド定義で宣言される場合がある 2つの構造体では異なる型となりうるからbindを意識すれば問題ない     コンパイル時にジェネリックなコードを具体的な型を持つコードに単層化する  コンパイル時に、ジェネリックスをもったコードで使用された値を読み取り識別し、展開し、ジェネリックな定義を特定の定義と置き換える よって、実行時に、ジェネリックを使っているから遅くなる、ということはない   トレイト  特定の型に存在し、他の型と共有できる昨日について、Rustコンパイラに伝える 共通の振る舞いを抽象的に定義できる   トレイト境界  これを使用すると、あるジェネリックが特定の振る舞いをもつ、あらゆる型になりうることを指定できる   型の振る舞い  その型に対して呼び出せるメソッドから構成される 異なる型でも同じメソッドを呼び出せるなら同じ振る舞いを共有することになる   トレイト定義は何の手段か  メソッドシグニチャをあるグループにまとめ 何からの目的を達成するのに必要な一連の振る舞いを定義する   トレイトの作り方  trait Trait名 {} traitブロックでトレイトを実装する型の振る舞いを記述する  メソッドシグニチャを定義する メソッドシグニチャは;で終わらせられる。  {}で入れるはずの本体、このトレイトを保持する型がその実装を行うようにさせれる。       "},{"ref":"https://2222-42.github.io/2020/11/26/20201126log/","title":"20201126log","section":"post","date":"2020.11.26","body":"ブログを付けていると、自分の悩みを追いかけやすく、かつ深く考えやすくなるなと実感している。 そして、自分の一か月での変化にも気づく。さらに、反省をしやすく、明日によりつなげやすくなる。今日はそんな話。(PCの問題は解決しました。全部私が悪い。)\ndiary lifestyle being regular/on time 規則正しい生活や、定刻通りに動く生活、また、毎日着るものにルールを持たせることを心掛けている。\n私は規則通りに動くことの難しさとその喜びを知っている。\n毎日、毎朝、プログラミングの勉強をして、 仕事をするときはネクタイとスーツをして、 朝9時から夕方18時まで仕事して、 ISSUEはしっかり書く。\nこういう生活をしていたら、すごいと言われることがたびたびあった。\n確かに、こういったことは簡単であれど、実現するのは難しい。私は確かにそれをやり遂げている。\nだが、しかし、私は不完全であり、今もなお、60点くらいの人生しか送れていないのは事実である。\ntired しかしながら、疲れを人は覚える。さらに、疲れは人の生活にとっての敵である。\n今日は明確に疲れを覚えていた時があった。正確に言うと、活力がない。そして、それゆえに誘惑に流れる。そんな時間があった。\n原因を探ると、 想定していなかったことがあったり、 想定していたことであっても、想定よりも難しかったり、 そういうことが多かった。\nイレギュラーなことに対応しきれないという反省がある。 この手のは正しく振り返りの時間を設ければよいのだが、あれをやろうとか、あれをやらねば、ということが心を支配し、それによって力が十分に発揮されなくなってしまい、冷静に時間を設けることをおろそかにしてしまいがちである。 そして、それによって負のスパイラルに陥り、疲れ、活力を無くし、誘惑に流れてしまう。\n疲れたとき、戸惑った時は、一旦立ち止まり、正確に観察しよう。 早い失敗はよいことであり、失敗は選択肢のうちの1つである。(そう、一時間で行うことはある意味で挑戦なのである。私は一か月かけて、自分が素早い挑戦を実施する糸を見つけられたのである。) 恐れず、立ち止まり、ゴールと現在地点を把握し、どの手段を用いるかを考えなければならない。\npray どうか疲れを覚えたとき、誘惑に流されそうになった時、主に感謝し、祈り、喜びを持って、そして、霊の火という活力を消さずに、活動できるようにならせてください。 どうか預言を思い出させ、深く受け止めさせてください。 全てを吟味し、良いものを大事にさせてください。あらゆる悪いものから遠ざけさせてください。\n言うに遅く、聞くに早く、怒るに遅い、そういう人でいさせてください。\nvision 私にはなりたい人物像・なるべき人物像に関するクリアなビジョンを抱けていない、ということはここで繰り返し語っている。\nチームのビジョン設定を自分のビジョンに流用できないだろうか。\nつまり、コアバリューと目的との相互反復から、ミッションを作り、そこからストラテジー、さらにゴールを導く、というものである。 それぞれの詳細は以下の通りである。\n CoreValue  チームの基礎的な信念   Purpose  チームの存在理由 チームの組織への影響力   Mission  達成しようとしている目的   Strategy  ミッション達成のために将来にわたって天下宇する手段   Goal  ストラテジーを短期的で達成可能な目標へ落とし込んだもの    人間の場合は、目的というのが付与されているわけではなく、また、個人を特徴づけるような明確な統合的全体があるわけではない。\nここから、すぐにはわかない。\nただ、組織の特徴づけというのは、人間の特徴づけというところと大きく外れているわけではないと思う。 だから、繰り返し、これについて自分に問いかけ直そうと思う。\n 「私の基礎的な信念は何か」  人との交わり・関わり、およびその場を大事にしている 情報や技術は個人の問題および人間関係の問題を改善・解決に導く 規則正しい生活はよいことである。   「私の存在する理由とは何か」「私の社会、世界への影響力とはどれほどのものか」  もちろん、この世を罪から救うという目的はある。   「私が達成しようとしている目的はなんだろうか」「どういう人物像になりたいのだろうか」  キリスト者  言うに遅く、聞くに早く、怒るに遅い     「長期的に、目的のために、なりたい人物像のために、どういうことをやっていくのがよいか」 「今年一年など短期的に、どういう風に成果を出せるだろうか」  規則正しい生活を送る 言うに遅く、聞くに早く、怒るに遅い、そんな人    戦略が思い浮かばない。それは目的が明確ではないから。 目的が明確ではないのは、また、信念と存在理由の明確化ならびに相互反復がなされていないから。\nこれらを明確にしたら、もしかしたら、私は自分のなりたい像のクリアなビジョンを抱けるのかもしれない。\npray 主よ、どうかキリストという模範を私の心にとどめさせてください。\n愛、喜び、平和、寛容、親切、善意、誠実、柔和、節制、これらを身につけさせてください。\n神の目を通して、キリストに繋がっている私の、なるべき像・なりたい像のクリアなビジョンを抱かせてください。\npc グリスを塗り直した。\nラジエーターを取り付けるときに、ファンコントローラーからピンを外した記憶がなかった。\nつまり、接続不良が問題だった可能性がある。\nこれによって、CPU温度は40度以下になり、正常な動作をPCがするようになった。\n今日の勉強 rust  ジェネリックスを使用して関数定義  引数や戻り値のデータ型を指定する関数のシグニチャにジェネリックスを配置する。つまり、 本体で引数を使用するときはシグニチャで関数名を宣言し、  コンパイラに分からせるため   関数シグニチャで型引数名を使用する時は、使用する前に型引数名を宣言  型引数名は短く、命名規則はキャメルケースという規則があるのでTとなることが多い fun name \u0026lt;T\u0026gt; () ...  この関数は何らかの型T(型名宣言された型変数)に関してジェネリックである  Tそのままだと、すべての可能性のある型に対して動作できないとコンパイルエラーになる  特定のトレイトをもつ、と指定する方法がある           構造体を定義して\u0026lt;\u0026gt;記法で、1つ以上のフィールドにジェネリックな型引数を使用できる  型引数名でバインドされるので、同じインスタンスの同じ型引数に異なる型を入れることはできない。 所望の数だけ定義でジェネリック引数を使える  が、2、3個以上になると可読性が落ちるので、コードの小分けが必要なサインと捉えよう。   e.g., struct Name \u0026lt;T\u0026gt; {..., filed: T, ...} e.g., struct Name \u0026lt;T, U\u0026gt; {..., filed1: T, field2: U, ...}   enum定義でも列挙子にジェネリックなデータ型を保持できる  Option\u0026lt;T\u0026gt;やResult\u0026lt;T,E\u0026gt;がそれ。   方針: 保持している値の型のみが異なる構造体やenumの定義を認識したら、ジェネリックな型を使用することで重複を避けよう。 "},{"ref":"https://2222-42.github.io/2020/11/25/20201125log/","title":"20201125log","section":"post","date":"2020.11.25","body":"PCで発生していた問題の原因と思われるものの1つを特定(私が悪い)。音声によるコミュニケーションの問題の一時対処をやっていることの気づき。\nあと、色々勉強した記録(Rust、Isabelle、1on1)。\ndiary pc CPUの温度がやばいのが原因だと判明。\nとりあえず、IPAと熊グリスを購入。明日、塗り直しをする。\nここ2年ほどグリスの塗り替えをしていなかったので、全部私が悪い。\ncommunication 音声を用いた一次元的な伝達内容の作成と連絡が苦手、という話を昨日のweblogで記録した。\n今日は、初めて会う人とオンラインミーティングをした時に気づいたことがある。 人と会話をするときに、この苦手を露出させないようにするために、ある程度、自分で発言や思考、振る舞いを調整できている。\n具体的に行っている対処は、複雑な内容を語るときは、話す内容を分割し、短いセンテンスにしている。 さらに、相手の反応を見たり、相手に問いかけたりしている。\n自分の苦手さを克服しようとしている傾向に自分で気づけた。\nただ、そこでまた別で気づいたのだが、初めて会う人との会話では脇汗がすごい出る。\nalocohol ビールを飲むと寝ている時に痒みが出る。\nお酒はやはり控えようと思う。\n今日の勉強 rust TRPL pp.175-187\n  エラーを委譲する\n Result型の値を扱う  失敗したら、panic!を呼び出す代わりにエラー値を早期リターンし、それを呼び出し元に返す 成功したら次の処理で値を取り出し、Result型の値を返す  操作し、返すのはResult型 最後の式だったら、returnは不要     全体の返り値はResult型となる  呼び出し元のコードに成功や失敗情報を全て委譲する、そしてそこには十分な情報があるはずなので適切に扱える      エラー委譲のショートカット: ?演算子\n 定型コードの多くを排除できる ?演算子  matchを使った定型コードでやっていたのと類似の動作をする  Okなら、その中身がこの式から返ってくる Errなら関数全体からErrの中身が返ってくる、早期リターンする  Errの中身はFromトレイトで定義され from関数を呼び出すと  受け取ったエラー型が、 現在の関数の戻り値型で定義されている エラー型に返還される       関数が失敗する可能性を全て1つのエラー型で表現して返すときに有用 ?演算子の直後にメソッド呼び出しを連結することができ、それによってコードを短くできる   ?演算子は、Resultを返す関数でしか使用できない。  match式を使った定型コードと類似の動作をするのだから ResultやTryトレイトに関しての怒られが発生する      エラーを呼び出し元に委譲するなら、?演算子\n  Resultを返さない関数ならmatchかResult\n  panicすべきかResultを返すべきか、その決定方法\n 分類  panic  回復不能   Result  呼び出し側に、回復不能と断定するか、回復を試みるかと、選択肢を与える     ほとんどResult型がよいが、panicが適切になる場面はある panicが適切になる場合  例  つまり、何らかの概念を具体化しているとき 頑健なエラー処理コードが例の明瞭さを欠かせる panicする可能性があるところというのは、アプリ側で処理してほしい方法へのプレースホルダーを表示する   プロトタイプ  エラーの処理方法を決定する前において プログラムを頑健にする明らかなマーカーとなる   テストコード  呼び出しがテスト内で失敗したら、テスト全体が失敗してほしい つまり、テストが失敗と印づけられる手段として、unwrapやexpectが必要     コンパイラよりもプログラマがより情報を持っている場合  Ok値であると確認する何らかの別のロジックがある場合、unwrapした方がいい  プログラマは知っている コンパイラは知らない   特定の場面では起こりえないが、一般的には失敗する可能性がある時 ユーザー起源のもので、それゆえに確かに失敗する可能性がある場合、  Resultをもっと頑健な方法で対処したほうがいい        panicすべきかどうかのガイドライン\n 悪い状態に陥る可能性があるとき、パニックさせる  悪い状態とは、何らかの前提、保証、契約、不変性が破られるとき  関数には契約がある  入力が特定の条件を満たすときにのみ振る舞いが保証されている 破られた時にパニックするのは道理に適っている       panicを起こして、自分のコードの使用者にバグがあることを通知したり、外部コードで修正しようのない無効な状態を返す時がある Resultを返して、悪い状態を委譲して、呼び出し側が、問題の処理方法を決定できるようにするという選択が良い場合もある コードは  値が合法であるか確認し、 合法でなければパニックになるべき。  これは安全上の理由による        検証のために独自の型を作る\n たくさんのエラーチェックを行うことは冗長で煩わしい Rustの型システムを使用して、合法な値があると、コンパイラがすでに確認している  確実性を持って前に進める   ifでの値チェックする方法は、理想的な解決策ではない  面倒だし、パフォーマンスへの悪影響がある   新しい型を作って、関数本体内で確認するのではなく、検証をその型のインスタンスを生成するところに追いやる  関連案数で、それを生成するところでふるいにかける  フィールドを非公開にし、直接セットさせず、インスタンスを生成せざるえなくさせる この関連関数の契約を明示する方法については、ドキュメントの規約に書けばよい(cf: chap14)     関数が新しい型をシグニチャに用い、受け取った値を自信をもって使用することは安全になる  受け取った値を取り出すゲッターというメソッドを作らないといけない。      10章\n ジェネリックス  概念の重複を効率的に扱う道具  独自の型、関数、メソッドをジェネリックスとともに定義できる  コードの重複を減らせる     具体型や他のプロパティの抽象的な代役  ジェネリックスの位置に何が入るか知ることなく ジェネリックスの振る舞いや他のジェネリックスとの関係を記述することができる  トレイトを使用して、ジェネリックな方法で振る舞いを定義できる  ジェネリックな型とトレイトで、型を特定の振る舞いのある方のみに制限できる       ライフタイム  コンパイラに参照がお互いにどう関係しているかの情報をどう関係しているかの情報を与える一種のジェネリックス これのおかげで  コンパイラに参照が有効であることを確認してもらうことを可能にしつつ多くの場面で値を借用できる       関数の抽出と、ジェネリックスを使用するのも同じようなこと  関数の抽出の仕方  まず重複したコードを見分ける 次に関数を抽出する  関数に渡す可能性のあるあらゆる値の具体的な型を示す 入力と戻り値を関数シグニチャで指定する   取り除く  関数を代わりに呼び出すように更新する     ジェネリックスは、抽象的な型に対して、処理するコードを可能にする    isabelle  L_correctの証明を追いかける。  テキストにダイアグラムがあり、 Isabelleのgoalsを解釈しながらだと、 証明の内容と証明すべきことがすぐわかった。   Optimizer buryの定義を読む  死んだ変数へのアサインメントを、SKIPに置き換えることで、除外する   このOptimizationが正しいことの意味について  基準は、変形されたものがもとのものと同じかどうか、である。    team 『1on1マネジメント』を読み進める\n読み進めながら思ったことは、『Team Geek』とGoogleのガイドラインを足して、日本の中間管理職向けに(チームおよびチーム文化の側面や、チームメイトであるというところが抜けているような印象を受けたので「管理職向け」と私は感じたのだろう)、具体例を盛り込んだような内容。\n退屈であるが、具体例に富んでおり、また、Googleの方々の欧米ライク、もしくは、日本人に合わないところを、日本の状況に合わせている点は好印象。\n時々読み返して、振り返ってみて、自分を改善するところでは役に立つかもしれない。\n"},{"ref":"https://2222-42.github.io/2020/11/24/20201124log/","title":"20201124log","section":"post","date":"2020.11.24","body":"PCの問題の記録。コミュニケーション苦手と感じる理由は、音声という一次元的な情報の伝達手法に難を覚えていることと関連している。読むべきVPoEのインタビュー記事のリストアップ。\nあと、Rustの勉強記録(Result型周りの途中)。\ndiary pc また勝手に再起動が走った。\n自動的に再起動するのをやめさえることにした。これで一度様子を見よう。\n次はフリーズした。電源の問題ではないことがわかった。\nBIOSの更新をして、これでもダメだったら、部品の交換をしなければならないだろう。\ncommunciation コミュニケーションが苦手と感じている理由は、思考と文法とが一致しないことが多い。\nこうやって書いているときも、考えを改めてみたり、もしくは書いている途中で、末尾の動詞を変化して文章がおかしくなったり、順序を変えて助詞がおかしくなったりする。\nこれが話しているときは問題として顕著に表れる。\nだから、コミュニケーションが苦手ということを語るうえでは、音声会話における一次元的な表現が苦手であることをとりあげないといけない。\nteam 会社で『Team Geek』の要約の発表をしているときもそうだ。\nTeam Geekの内容は当然であるが、当然のことを文章としてまとめ、これの重要性を箇条書きで伝えることは、実感を得ていますか？実践できていますか？と問いかけることにおいては重要である。\nvision VPoE kiitokで結構まとめられていたので\nメルペイ 木村さん\n tech-street kiitok  アカツキ 湯前さん\n kiitoku  Wano 橋本さん\n Wano Blog  読んでないけれど、これらを読んで調べよう\n今日の勉強 rust TRPL pp.170-175\n Result enumが伝達するもの  File::openを例にすると  成功したか失敗したかを知らせる方法と ファイルハンドル(中身、Okインスタンス)、または、エラー情報(エラーの種類の関する情報をより多く持つ、Errインスタンス)      let f = match f { Ok(v) =\u0026gt; v, Err(e) =\u0026gt; { ... e ... }, }; 上記のように、match式でバインドして取り出すことができる\n 失敗理由によって動作を変えたい場合  io::Errorのインスタンスにkind()メソッドを適用すると、io:ErrorKindの値が返される  io:ErrorKindはenumで、io処理の結果発生する可能性のある種類のエラーを表す列挙子がある   マッチガードを使う  matchアームの後にif ... アームのパターンをさらに洗練するmatchアーム上のおまけの条件式  アームコードを実行されるにはこれが真でなければならない 真でなければmatchの次のアームを考慮する     パターンでrefを使用する理由  errorがガード条件式にムーブされないようにするのに必要 ただ単にガード式で参照される  \u0026amp;の代わりにrefを使う理由  \u0026amp;: 参照にマッチし、その値を返す ref: 値にマッチし、それへの参照を返す       matchだと多少冗長になるので、ヘルパーメソッドがある  unwrap  Ok列挙子ならその中身を返し Err列挙子ならpanic!マクロを呼ぶ   expect  unwrapと似ているが、 Err列挙子の場合に、panic!のエラーメッセージを選択させてくれる  パニックの原因とその箇所を特定しやすくする         エラーの委譲  定義  関数内でエラーを処理する代わりに 呼び出し元がどうするかを決められるようにエラーを返す   方法  Result\u0026lt;T, E\u0026gt;型の値を返すようにする  TとEは具体型で埋める  この型の決め方は中身の関数から決める         "},{"ref":"https://2222-42.github.io/2020/11/23/20201123log/","title":"20201123log","section":"post","date":"2020.11.23","body":"自分の短期的なモチベーションと、隣人の必要に焦点を合わせ貢献をするという視点から、自分のなりたい像についてのぼんやりとしたビジョンと、サンプルを探すことへの決断。\nあと、Rustの勉強記録。\ndiary motivation 内的な理由はない。\nその時その時で、神の御心に従ったことを行おうと務めているだけである。\n短期的な視点で見ればこれでもいいのだろうが、 長期的な行動の理由付けや、自分のなりたい像を抱けていない。 そのため、今、何をすべきかを悩んでいる。\nvision ある程度の期間、覚えているなりたい像としては、次のようなものがある。 その時その時で私は、その場の会話で適切な振る舞いをしたく、それはまるで喫茶店のマスターのような生活を送りたいという感情がある。 (人と関わることは疲れることである一方でとても楽しいことである。)\nあいまいなビジョンはあるが、これでは長期的な計画をたてられない。もっと明確なビジョンを持たねばならない。\nこの曖昧なビジョンをもう少し掘り下げると、以下のような深いコミットメントへの関連性が出るだろう。\n 「もしその時の会話がその後の影響を大きく及ぼすことであれば」、 「もしそういった会話が出てこないような環境であったならば」、  そして、自分の今の立ち位置を考える。\n 自分がエンジニアであること 技術やエンジニアのことを多少なりわかっていること、 ビズ側や他者の人間とも多少話せること。  また、周囲の状況を考える。\n エンジニアを相手にすることが難しいと感じる人が多いこと。 エンジニアとしての要望をうまく伝えることが難しい人がいること。 人とのコミュニケーションで心を殺せない人がいること。  上記の箇条書きは引き算的なものでしかない。 何になるべきか、何になりたいか、ではなく、何になりうるか、という視点に寄ってしまう。 特徴はあれども、明確なビジョンが抱けられない。\nsample もし上記の引き算で得られる将来の人物像としてVPoEと呼ばれる職種の人間が候補が適当であると仮定しよう。 (実際のところ、VPoEと呼ばれる人が何をやっているか知らないし、その責務も知らないのだが)\n実際にVPoEをやっている人のサンプルを探し、自分のなりたい像について、なんらかのシンパシーを感じるかを考察してみようと思った。\nアジャイルマスターやってるとか、採用やってるとか、そういうのじゃなくて、エンジニアのバックアップをして、チームをよりよくしようとしている本物を探そう。\nroutine アドレナリンの出るような、よい生活をするために、やっていることこと\n 食事を決まった時間に取る  そのためには決まった時間に出退勤をする   定期的に適度な運動をする  毎朝毎晩の体操はやっている(5分もない)  日、水、土、これらの日はもう少し筋トレなどをしようと思う     肉を食べる、蒸留酒を飲む、ニコチンを摂る  酒の量はちゃんとコントロールしなければ大変なことになる    今日の勉強 rust TRPL pp.165-170\n エラー  生きている証拠 エラーの可能性があれば、コンパイルで指摘し、対処し、それによって頑強になる   エラーは2種類ある  回復可能  問題を報告し、処理を再試行するのが合理的なもの Result\u0026lt;T, E\u0026gt;   回復不可能  常にバグの兆候 この時に実行を中止するpanic!マクロあり   例外はRustには存在しない   panic!マクロ  失敗のメッセージを表示し、  パニックメッセージと ソースコード中でパニックが発生した箇所を示唆する  バックトレースを使用して自分のコードの個所を割り出せる     スタックを巻き戻し、掃除し、  スタックを遡り、遭遇した各関数のデータを片づける  これはやることが多い だから、即座に終了させるように切り替えることができる     終了 コードに存在するバグによりライブラリでpanic!呼び出しが発生する  e.g., 無効な添え字  バッファー外呼び出しになり、これはセキュリティ脆弱性につながる そこで、Rustは実行を中止し、継続を拒む   バックトレース  ここに至るまで呼び出された全関数の一覧 読むコツ: 頭からスタートして、自分のファイルを見つけるまで読む  どのようにパニックを引き起こす値がここにたどり着くか割り出すために、調査を開始すべき箇所が、自分のファイル 代わりにコードは何をなすべきか算出   OSやRustのバージョンの情報とともに、バックトレースを得るには、デバッグシンボルを有効にしなければならない  --releaseオプションなしでcargo buildやcargo runすると標準で有効になる         Resultで回復可能なエラー  enum Result\u0026lt;T,E\u0026gt; {OK(T), Err(E)} T, Eはジェネリックな型引数  これを含むので、成功したときとエラーの時に返したい値が、異なるような様々な場面で使用できる  (型注釈を与えて、コンパイルしたら、コンパイラが型が合わないと教えてくれる)       "},{"ref":"https://2222-42.github.io/2020/11/22/20201122log/","title":"20201122log","section":"post","date":"2020.11.22","body":"内なる理由が見当たらない。自分の位置が分からない人は、自分の行く先もわからない。\ndiary motivation 自分の価値観がわかっていない。 この事象を換言するなら、任意の時点での自分の行動の理由が全く思いつかない、とでもなるだろう。\n自分の行動を振り返っても、その理由には、衝動と他律、あとちょっぴりの道徳観、それだけしか思いつかない。 (ちょっぴりの道徳観というのも、せいぜい好き嫌いのレベルである)\nほとんどの行動が直観的である。 この直観に内的な動機や価値観があると予測するのは、予測するだけただであり、語られていなければ存在しないことと一緒である。(予測だけでは無価値である) 後になってどう語られようとも、それが語られるまで、それの存在は明らかにされず、結局、今のところ私は衝動と他律でしか動いていないとしか思えない。\n衝動と他律でここまで生き残ってきたのは、他に道がなかったからこの道を歩んできた、という選択が多すぎてきたことが関係するだろう。\n強い理由でもって選んだことがない。 そして、その結果、自分は自分がなりたい人物像も抱けていない。 自分の現在位置がわからない人間は、自分の行く先もわからない。\nそんなわけで、個人のこれまでの内的理由を問いただしたり、これからの目標を聞いたりすることは、とても難しいだろう。 まぁ、そういった理由を求めるのは、会社が組織の人員に対して組織として成長することを求めているような人だからだろう。 個人の理由よりもチームの文化があった方が楽だろう。\n今日の勉強 rust TRPL pp.163-164\n 練習問題  整数のリストが与えられ、ベクタを使って以下を求めよ  mode  ハッシュマップのvalueでの比較して最大値をとるものは、よくわからないからググったら出てきた。 ググった結果のものを読んで、理解できたから、それを使った。     ピッグ・ラテンの実装  文字列が配列の要素に入っているかどうかというRailsとかによくある表現がググってもヒットしなかった だから、match使った。母音は複数あるのでmatchの条件でorとなるように使う。 文字列の操作はパッとすっきりした解答が得られなかった  strを使う関数と charを使う関数の2つを実装した。  chars.nth(n)でn番目の要素が消えるの、直観的じゃないけれど、所有権を移しているからそれはそうか。       ユーザーと部門の登録と一覧の実装  とりあえずユーザーを部署と合わせて登録するようにした。  部署の型については特に決めていない。  部署を無限に追加できる。 次の章のエラー処理で扱うべき問題がいくつか感じられたからである。   無駄にmutableにしているところもある。   filter機能  filterしたあとでcloned()しないといけなかったのはなぜだろうか？ エラーメッセージに従い続けただけなので、何もわからない。   sort  ドキュメントを読んだら、二つの要素で二重にソートするなら、.then(...)というのが使えることがわかったので、それを使って、ソートした。        isabelle Concrete Semantics\n Liveの再帰的関数  control flow graphでWHILE b DO c (w)について見る 求められる性質  vars b \\subseteq L w X X \\subseteq L w X L c (L w X) \\subseteq L w X  これは、以下のgenから証明できる さらに、L w Xが最小解であることを証明することができる  そしてそれは、L w Xの定義が最適であることを意味する         class 内のAnalysisはA c S = gen c \\cup (S - kill c)である  kill  ちょっとわかっていないところは以下の２つ  kill (c1;;c2) = kill c1 \\cup kill c2 kill (IF b THEN c1 ELSE c2) = kill c1 \\cap kill c2     gen  gen (c1;;c2) = gen c1 \\cup (gen c2 - kill c1)     Big-Step Semanticsに関してLが正当であることのフォーマルな証明  2つのコマンドcの実行の初期状態がLcXにおいて一致しているならば、対応するそれぞれの最終状態においても一致していること  等しいことはf = g on Xというものを使っている。   simulation propertyから、Liveness Analysisの正当性の証明になる    1on1 松岡啓司『1on1マネジメント』という本を読み始めた。\nなんか『Team Geek』と比べると、自分の層にあっていないような感じがする。\nこの本は、どちらかというと、十年とかそれくらい務めた人で、マネージャー層と言われる人に向けて使われているような気がする。\nチームよりも個人とマネージャーという感じが強く感じられる作りになっている。 今私が一番悩んでいるチームの文化についての解答が得られなさそうな予感がする。\n"},{"ref":"https://2222-42.github.io/2020/11/21/20201121log/","title":"20201121log","section":"post","date":"2020.11.21","body":"休息の日であった。先日からのPCの不具合の原因と思われるものを1つ特定した。\ndiary rest 休息の日なのでだらだらと過ごす。\npc pcがおかしな挙動をする原因、というか、唐突に再起動する原因についてだが、同僚からもらったDACもしくはその接続が1つの原因かもしれない。\nこれに気づいたのは、DACを接続し直した時に、Alt+F4の時と同じ挙動が発生したからである。\nとりあえずDACを押し入れに入れた。 (HDDの交換はやらねばならないのは変わらない。SSDの交換もやりたいが、金がない。)\nsound DACを含めた、音響機器というのは、私にとっては扱いが難しいものである。\n結局、この手の機材というのは、特定の音を強調したい場合や削りたい場合に効果を発揮するものであり、それほどこだわりのない私には勿体ないものである。\n平沢進さんが、フリー音源だけで曲を作ったことがあるという話を聞いたが、他の人でそういう話を聞いたことがない。 もちろん、フリー音源で作ることは誰でもできるが、たいていの場合は中途半端であり、出したい音や削りたい音を理解している人であるからこそ、お金を払って、機材や素材を集め使い、素晴らしいものを提供できるわけである。\n現にDACの有無で何が変わるのか、私にはわかっていない。\n今日の勉強 rust TRPL p.163\n HashMapはハッシュ関数を利用している  ハッシュ関数  パフォーマンスの欠落と安全性とのトレードオフ関係がある 標準のハッシュ関数が自分の目的では遅い場合は  異なるhasherを使おう、指定できるから  hasherはBuildHasherを実装する型         練習問題  整数のリストが与えられ、ベクタを使って以下を求めよ  mean median mode  ハッシュマップで、valueが最大値となるものを求めるものの実装が思いつかない。　        isabelle Concrete Semantics\n 最適化のもう一つ  後で必要のない値の変数へのassignmentの削除   変数がLiveであるのは  コマンドcの実行前の変数xの初期値が、コマンドc実行後の最終状態に影響を影響する場合  この条件の弱いバージョンは以下の通り  変数xが上書きされる前の初めて読み込まれたところで、 コマンドcのなんらかの潜在的な実行がある場合       変数がdeadであるのは、  変数がliveでない場合   Liveの再帰的な関数の実装  もとの変数の集合から、アサインメイントの時に、代入される変数を削って、割り当てられるものの変数を追加する これを再帰的に定義している   "},{"ref":"https://2222-42.github.io/2020/11/20/20201120log/","title":"20201120log","section":"post","date":"2020.11.20","body":"増えたタスクに対してやりやすくしておくことが重要で、それが職業コードとしてよいコードであることなんだろうなと思った\ndiary work やることはやっているうちに増える。 気づきを得て、新たに挑戦することができる。\nまた、事前にやることをやっておくと、増えたやることへのアクションをとりやすくなる。\n結局、クリーンアーキテクチャとか、きれいな設計とかは、後の土台作りとなっているから大事にされている。\ncommunication コミュニケーションをできているふりを私はしており、そのための演技をしているから、痛みが少ない。 コミュニケーションをできないこと、心を通わせられなかった時、これらへの絶望をなくすために、心を殺す。\nネクタイを締めたら、カーテンが上がる。 私はコミュニケーションをしているふりをする。\n舞台上のキャラクターを演じる役者は、そのキャラクターに重ねていれど、その演劇が終われば、そのキャラクターの感情を引き継ぐことはない。 それと同じで、会話において役割を演じ、自分がコミュニケーションをしているような振る舞いをする。 それを見ている相手は、その通りに感じ、終わった後で役者はそれを振り返り、次の演技や舞台への反省につなげる。 しかし、舞台上での痛みは引き継がない。あくまでも舞台をうまく回せたかどうかを気にする。\nVPoE しかしながら、人間関係と世界は続く。しかもそれは根強く。 幕が降りることはない。 正確に言うと、延々と舞台が続き、同じ演劇は上映されない。\nさらに、舞台には監督がいる。 役者同士の演技をまとめあげ、次の舞台をよりよくするためには、監督が必要だ。\n脚本家もいる。\nだが、現実世界でのコミュニケーションにおいては、そういう人間は舞台の外にはいない。 いや、舞台上で演技している俳優は、舞台外の人間を見ていないし、舞台外の人間は舞台上の人間に指示を出せない。(主よ、あなたの聖霊に、私をあなたの望む場所へと、導かせてください。) 舞台上で俳優が俳優をまとめる。\n脚本を書く人を用意し、大道具と小道具とを揃え、俳優の体調に気を配り、照明をセットし、エンディングでの賞賛を聞かせる。\nwho I am 結局、自分が何者かを理解しているものが、強い。\nそして、どういう人間になりたいかを理解している者は、より強くなる。\n(キリストは、自分が何者かを正確に記述し、自分が磔刑に処せられ神の御許に行くことを望み、その道を歩んでいた。)\n私は何者で、どういう人間になりたいのか、わからない。\n今日の勉強 rust TRPL pp.160163\n HashMapと所有権  CopyTraitのある型の値  HashMapにコピーされる   Stringのような所有権のある値  moveされる   値への参照  moveされない     HashMapの値へのアクセス  get(\u0026amp;key)メソッドでOption\u0026lt;\u0026amp;T\u0026gt;を得る forループでハッシュマップのキーと値のペアを得る  for(k,v) in \u0026amp;hash_map {}  k: \u0026amp;T、v: \u0026amp;Tとなっている       HashMapの更新  上書き  同じキーでinsertする   キーに値がなかった時に挿入(古い値の保持)  .entry(key)でEntryというenumを得て .or_insert(value)で更新  存在したらその可変参照を返し 存在しなかったら引数を新しい値として挿入した可変参照を返す   自分で書くより、綺麗でborrow checkerとの親和性もある   古い値に基づいて値を更新  for文で .entry(key).or_insert(value)などで可変参照を取得し *で参照外しをして更新  可変参照はforのスコープで落ちるので、 変更は全て安全に行われる       "},{"ref":"https://2222-42.github.io/2020/11/19/20201119log/","title":"20201119log","section":"post","date":"2020.11.19","body":"潜水しているような気分が続く。\n人と会話するとき、まるで息を止めていたかのような疲れを覚え、すごく底に潜っていたことに気づく。\n潜水なのか、それとも、沈没か。\nこの潜っている感じがいつまで続くかわからない。\n火をつけたタバコを吸いたくて、手巻きをする。\n今日の勉強 rust TRPL pp.155-160\n  Stringの内部表現\n StringはVec\u0026lt;u8\u0026gt;のラッパ  Stringの長さはUTF-8エンコードされたベクタの長さになる   添え字で取得しようとすると、UTF-8エンコードされた最初のバイトが帰ってくる  ユーザーはバイト値が帰ってくることを期待していない  Rustは誤解を防ぐためにCompileしない        UTF-8の別の要点\n Rustの観点から文字列を見る方法  バイト  u8値のベクタ   スカラー値  char型   書記素クラスタ  人間が文字と呼ぶもの     添え字アクセス禁止理由  Rustは添え字アクセスという処理が常に定数時刻(O(1))であることを望む  合法な文字がいくつあるかを決定するのに、文字列の中身を全体操作する必要があり、時間がかかりすぎてしまう        文字列にアクセスる方法\n スライスする  範囲として[]を使って、特定のバイトを含む文字列スライスを作れる  無効な範囲だったら実行時にパニックする(Compileは通る)     走査  charメソッドを使用し、char型の値を返す bytesメソッドで、各バイトをそのまま返す  合法なUnicodeのスカラー値は、2バイト以上からなる場合もある点は注意   書記素クラスタを得る方法は複雑なので、標準ライブラリには入っていない      トレードオフ関係\n 文字列の複雑性の露出と エラーの起きる可能性の排除    ハッシュマップHashMap\u0026lt;K,V\u0026gt;\n K型のキーとV型の値にチア王関係を保持する ハッシュ関数を開始て行う  これが、キーの値とメモリ配置方法を決める   ベクタのように番号ではなく、どんな方にもなりうるキーを使ってデータを参照したいときに有用 コレクションからHashMapをuseする必要あり  初期化処理で自動でスコープに導入される機能には含まれていない  よってサポートが少ない  生成するための組み込みマクロなし       データはヒープに保持される ハッシュマップは均質  キーは同じ型 値も同じ型      作り方\n new() + insert(key, value) collectメソッド  色々なコレクション型にデータをまとめあげる 型注釈が必要  HashMap\u0026lt;_,_\u0026gt;  アンダースコアを使用しているのは、元のデータから型推論するから         "},{"ref":"https://2222-42.github.io/2020/11/18/20201118log/","title":"20201118log","section":"post","date":"2020.11.18","body":"潜水をしているような気分だ。\ndiary 潜水をしているような気分だ。深いところで何かを探っていて、ふっと海面から顔を出し、息をする。そしてまた深いところに潜り直す。\nこういう気分になったのは修士課程以来だ。\n何を探しているのかはわからないし、これがいい傾向なのかすらわからない。\npc パソコンの調子が何かおかしい。\n メモリ: 問題なし SSD: 正常　 HDD: 注意  おそらくこいつが悪さをしている。\n雑に交換しよう。\n今日の勉強 team メモを一通り作れたので、summaryとして箇条書きを1つのファイルにまとめ、セクションを適当に区切った。\nrust TRPL pp.146-155\nベクタの中身を読む方法:\n 添字記法(\u0026amp;v[n])  \u0026amp;と[]を使って、 参照を作る   getメソッド(.get(n))  Option\u0026lt;\u0026amp;T\u0026gt;を取る   振る舞いの違い  ベクタに要素が含まれない番号の値を使用する  添え字記法だと、パニックする  存在しない要素を参照するから ベクタの終端を超えて要素にアクセス使用としたときクラッシュさせたい場合に有用   getメソッドを使うと、Noneが返される  普通の状態で、範囲外にアクセスする可能性がある場合に、有用       有効な参照がある場合、借用チェッカー(borrow checker)が所有権と借用規則を強要し、  ベクタの中身への、この参照や他の参照も有効であり続けさせる  可変と不変な参照は同時に成立しない       ベクタがある。 ベクタのすでにある要素への参照を取る。  不変借用が発生する。   ベクタにpushする。  可変借用が発生する。 ここで可変借用が発生するのは、ベクタが現在存在する位置に隣あっている要素を入れるだけの領域がない場合に、メモリの新規確保をして、古い要素を新しいスペースにコピーする、というベクタの動作法がある。   step2の参照を使おうとするとCompile Errorが発生する。   ベクタの要素に順番にアクセスしたい。  forループで走査すればよい  ベクタの各要素に対して、  不変な参照を得て出力したり   可変なベクタであれば、  可変な参照を走査して、参照外し演算子(*)を使用して、その値にたどり着き変更できる       ベクタに異なる型の要素を保存させたい  ベクタは同じ型の値しか保持できない enumを定義して、enum列挙子に異なる型の定義をし、enumの型のもとに定義されるようにすればいい  enumを使う利点  各要素を格納するのに、ヒープ上でどれくらいメモリが必要になるかわかるように、 コンパイラがコンパイル時に入る型を知る必要がある。   enumを使う副次的利点  どんな型が許容されるのか明示できる  ただし、プログラマが保持される一連の型を知らない場合はenumのテクニックはうまくいかない  その場合は、TraitObjectを使おう            文字列\n 文字列で行き詰まる人が多い  3つの概念の組み合わせで行き詰まる  Rustのありうるエラーを晒す性質 文字列あ複雑なデータ構造であること UTF-8     文字列をコレクションの文脈で語ることは有用である  なぜなら文字列は  テキストとして解釈されたときに有用になる機能を提供するメソッドと バイトの塊で 実装されているからだ  (メモ:これが理由となるのがわからない)       文字列  言語の核としては１つの文字列型しかない  文字列スライス  別の場所に格納されたUTF-8エンコードされた文字列データへの参照   ライブラリ  標準ライブラリのString  伸長可能、可変、所有権のあるUTF-8エンコードされた文字列型   その他の色々な型があるが、その名前と性質は  XxxString: 所有権あり YyyStr: 借用されたバージョン       文字列式  String::new() -\u0026gt; String String::from(文字列リテラル) -\u0026gt; String 文字列リテラル.to_string  Displayトレイトを実装する型であればなんでもよい 文字列はUTF-8エンコードされている  適切にエンコードされていたらなんでもよい     s.push_str(文字列リテラル)  文字列スライスを適用して、Stringを伸ばす 所有権を得なくていいので、引数には文字列スライスを取る       文字列を組み合わせる  +演算子  let s = s1 + \u0026amp;s2  addメソッドを使っている  addメソッドのシグニチャはfn add(self, s:\u0026amp;str) -\u0026gt; String   s1の型はStringであり、この所有権を奪って、 第二引数の中身のコピーを追記し、  s2の型はStringであり、addシグニチャの第二引数の型が\u0026amp;strで動くのか コンパイラが型強制、参照外し型強制をしている  \u0026amp;sを\u0026amp;s[..]に変えていると考えてもよい     そして、結果の所有権を返している     format!マクロ  format!(\u0026quot;{}...\u0026quot;, s1, ...) 可読性が高い 引数の所有権を奪わない Stringを返す      文字列に添え字でアクセスする\n 添え字記法でStringの一部にアクセスできない  Rustはそのサポートをしていないから  サポートしていない理由は、Rustがメモリにどのように文字列を保存しているかについての議論からわかる。      isabelle Concrete Semantics\n証明を追いかけたもの\n defs_restrict big_step_pres_approx_restrict approx_map_le restrict_map_le  疑問：declareの役割\ndeclare assign_simp[simp]という表現がないと証明できない箇所があった。\ndeclareの役割は何か？　useみたいな感じで引っ張ってきて、それにsimpで使うように宣言したりするようにすることか？\nその線でやったら、declareしなくてもできたからこの認識で多少あっていそうだ。\n"},{"ref":"https://2222-42.github.io/2020/11/18/summary-of-team-geek/","title":"Summary of Team Geek","section":"post","date":"2020.11.18","body":"『Team Geek』の箇条書きを一つのページにまとめる。\nHRT(謙虚、尊敬、信頼)、これらの欠乏が問題を引き起こす。\nそして、HRTの原理を、『Team Geek』では、以下のように広げていった。\n 自分 チーム チームをリードする方法 チームの外部とのやり取り(外部、組織) ユーザーとのやり取り  この手法は、エンジニアリングのみならず、あらゆるコミュニティが対象となる。\n0 章  プロジェクトの成功には以下の2つの要因が必要である  優れたコードという技術的要因と みんなの協力という人的要因  人間は難しく「人間は断続的なバグの大きな塊」 その一方で、チームは個人の生産性や幸福に直接影響する      1章(自分にHRTを持たせる) 1人の天才ではなくチームが全て  天才の神話  天才はコードを隠さない  優れたコードだとしても不十分   コードを隠すのは不安の裏返しである 天才の本当の功績は、チームとうまくやることができたこと 1人でやることは失敗のリスクが高まる。みんなでやることのメリットが高い。  失敗に早期に気づける  プロジェクトには、高速でのフィードバックループが必要   プロジェクトののバス係数が高まる スケールできる   チームが全て    HRTとその活用方法  謙虚(H: Humidity)、尊敬(R: Respect)、信頼(T: Trust)、これを自分が持ち、相手も抱けるような環境を作ることが重要。  HRT、これらが健全な対話とコラボレーションの基盤  これらが欠如すると人間関係が衝突する  人間関係は、プロダクトやプロジェクトより、長く続く   これらがあると、いざ困ったときに、助けられる   謙虚  エゴをなくす  コミュニティは信じられないほど強力なアイデンティティがある   自分の学習のための時間を作る   コードの指摘には謙虚になり、相手に尊敬を含め、相手が恩恵をもたらしてくれると信頼する。  (ebiebievidenceのTweetを見よ)   失敗、学習、反復  不完全を見せても構わないという謙虚さを持ち、 ユーザーが、対応を賞賛し、改善を要望するという信頼で、 失敗の文書化(ポストモーテム)をする  何を学んだか、何を改善するか     忍耐を学ぶ 影響を受けやすくする  間違いや能力不足を認める  謙虚さを見せる   他人の意見を信頼する この正直さと強さは尊敬を産む      要約している私のコメント このあたりの習得は、人やチームとのやり取りと、そこからのフィードバックで得られるものが多いだろう。\n2章(チームにHRTの原理を持ち込む) チーム文化  チーム文化を作ることで、自己選択的な文化になり、また、外部から来た悪意ある人や文化を排除することができるようになる。  文化はイースト菌のようなもの  そしてその種菌が重要   チーム文化とは、エンジニアリングチームが共有する、経験、価値、目標 まず優秀なエンジニアを雇う 強い文化は自己選択的な文化である  文化に合わない人は、事前に遠ざかってくれる   合意ベースのマネジメントなら、チーム全体が意思決定プロセスに参加できる  チーム全員がプロダクトの成功に強い責任を持ち リーダーがチームの意見に耳を傾けること(尊敬)   チームメンバーの接し方  HRTを持っていればよい 前向きな批判をしてくれる友達や同僚を見つけよう   文化が、積極的なのか、のんびりなのかを理解し、  新来者に支配されないように気をつけよう      チーム内でのコミュニケーション方法  コミュニケーションなしには正しいコードを書いている保証ができない。  同期コミュニケーションの人数を減らし  (後のミーティングの五か条を見よ。)   非同期コミュニケーションの人数を増やす  (決める人は少なく、伝える人は多く、とも言えるだろう。) (伝えられたからのフィードバックも用意しておこう。)     チームのハイレベルの同期  高いレベルで共通の目的を持つ 進捗を伝えるベストプラクティスに従う  (それはどういうものかはわからないが、HRTをみんなが持って、オープンにコミュニケーションできるようにすればいいのではないだろうか？)  (日報とかいうくそみたいなものは避けたい。) (日報自体は悪いものではないが、ああいう人間を無視したものは、形式的で無意味になりがち)     ハイレベルの同期のためには、  ミッションステートメントの共有 ミーティング  地理的障害があることを意識する 設計文書の共有       ミッションステートメント  やることは単純  チームの方向性を定義して、 プロダクトのスコープを制限する  Making GWT Betterの例を見よ     ミッションステートメントを書くことで  認識の違いを明らかにし 方向性に合意でき  これがなければ、スピードが落ちるか、停止するかのどちらかになる   共有することができる   再評価する  会社の方向性に合わせねばならない      ミーティングについての5つのルール  絶対に必要な人だけ  新しいものの設計で5人以上は不要 その時間に別作業している人は会議に参加しなくてもよい人だから誘うのを間違えている。   アジェンダを作って、ミーティング開始前に配布する  ミーティングを設けない日や時間を設けて、クリエイターの時間を設ける   ミーティングのゴールを達成したら時間前でも終了する ミーティングを順調に進める  取り仕切る人がいるようにする 15分以上のスタンディングミーティングをやめろ   ミーティングの開始時間を強制的に中断される時間の前に設定する  コミュニケーションで意識すること  地理的障害のあるチームで働くことを意識する  「メーリングリストで議論がなかったら何も起きていない」というモットー  チャットの後「リアル」としてのメーリングリストに投稿   リモートから話しかける時  机に向かって歩いていくかのような自然な感じであれ 積極的にチームとコミュニケーションをし  自分の存在だけでなく こちらの仕事も知ってもらう     フェイストゥーフェイスの帯域を過小評価してはいけない  (これは、このブログでもさんざん述べているが、かなり情報量が多い)     設計文書を、コードの前に、書くこと  未来のハイレベルな青写真  何をどうしたいのかを低コストでチームに伝える手段でもある。   設計文書は、コーディング開始後で「生きた文書」として扱う  プロジェクトの進行に従って、更新していくべき   設計文書を書くか、スクラッチから作るかは、経験で判断すること  設計文書を書く時間で何度もスクラッチから書き直せるなら、その文書は時間の無駄であったりする      ハイレベル同期完了後にやること ハイレベルのゴールに合意できた後で、\n チームの日々の調整に使うツールを与える  ツールはたいてい帯域が狭い  誤解やHRTの欠如に繋がる   でも欠かせられない  少しの手間で生産性を大きく高められる     メーリングリスト  議事録・ミーティングのメモ・決定事項・設計文書を記録するのには使った方がいい 検索可能にしておこう   オンラインチャット  いいぞ 物理空間の事情を考えなくていい  前提としては、通知をOFFにしていること     課題管理ツールを使おう  ただの掲示板 課題をオフィシャルにして、みんなの目に触れられるようにする  オフィシャルであるとは  粗暴な振る舞いを許すな 話や議論が長くなったらメーリングリストでやれ        エンジニアのコミュニケーションについてのリマーク  コードコメント  「なぜ」を説明するもの  「何」ではない   中庸を知れ コメントスタイルをチームで決めよ  一貫性を守る方が大切  関係なパターンマッチングによる推測が可能になる   使用を制限する機能についても決めておこう     Authorタグをつけるな 全てのコミットにコードレビューせよ  変更はレビューしやすいように小さく コードレビューは  品質を向上させ 品質に対するチームの誇りを育む     リアルなテストとリリースプロセス  自動テストを増やせば、バグ修正や機能追加の際に自信を持てる テストをコーディングやレビューのプロセスの一部にする  徹底的にテストを行え   頻繁にリリースできるようにリリースプロセスを調整せよ  ユーザーからの信頼を獲得せよ      文化の作り方  文化やコミュニケーションの習慣  好みの反映  「好み」には適切な人と正しい価値が必要   主観的ではない 自然発生ではない チームリーダーと創業者が  機能不全のチームのコストを理解して、 丁寧に種を播いて育てていくもの     文化の定義や防御よりもコードの設計や記述に時間をかけれる  防御には、新来者への説明を含む コードを書くことを目的とする強いチームを作ることには膨大なコミュニケーションが必要  コードは、人と人とのコミュニケーションである。      3章(チームをリードするときにHRTをもつ)  チームリーダーにならなくても、チームリーダーの行動を理解できるようになるからこの章を読め  チームリーダーがどのパターンを使って、成功(失敗)につなげているかを見て チームの原動力がより具体的に理解できる    リーダーとは  リーダーのいないチームは機能しない  かじ取りする人のいない船みたいなもの ソフトウェアの方向性に影響を与えるためには、エンジニアリングリーダーシップを隅々まで理解する必要がある   マネージャー  誕生  産業革命期 労働者を監督するマネージャーという立場  労働者を人参と鞭とで管理していた 今ではもう全く効果がない     変化  エンジニアは数か月間かけて新しいチームに追いつく 考えたり創造したりするためにの育成・時間・空間が必要   違い  昔のマネージャー  親と子の関係のようなもの どうやって仕事を完了させるかを考える   リーダー  HRTでエンジニアを信頼するようにすれば、エンジニアはその信頼に答える チームのための道を作り、安全と安心に気を配る 何ができるかを考える  どうやって完了させるかはチームが考える       二種類のリーダーがGoogleにはある  TL(Team Lead): プロダクトの全部・一部の技術的な方向性に責任を持つ TLM(Technical Lead Manager): TLの責任に加え、チームにいるエンジニアのキャリアや幸せという、人の管理にも責任を持つ      Managerになろうよ  Managerになることへの不安  コードを書く時間が減ることへの不安  定量化できないものが増えることへの不安  チームの幸せと生産性をたかめるのが仕事の指標である     無能なマネージャーになるのではないかという不安  ピーターの法則で、階級制度があるところでは、必ずその人の無能レベルまで昇進する     Managerになるべき大きな理由  自分をスケールできるから マネージャーに向いているかもしれないから  実際、マネージャーに向いていた人が多くいる     マネジメント病(管理したがり病)の負の再生産の問題について  サーバントリーダーシップで治療する  チームに奉仕すること HRTの雰囲気づくりをすること  アドバイスを与えたり、 順調に進めるよう穴を埋めたり 自らの手を汚す   技術的な側面とチームの人間関係の両方を扱う      マネジメントのアンチパターン  言いなりになる人を採用する  仕事が増えるぞ むしろ、自分より球が良くて、代わりになる人を採用しよう  新しいチャンスを産む     パフォーマンスの低い人を無視する  数名でもパフォーマンスの低い人がいるだけでチームはうまくいかなくなる 「願いは戦略ではない」  パフォーマンスの低い人にはコーチングをする  HRTとともに マイクロマネジメントをする  小さい目標から大きな目標へ マイルストーンには明確な期待を設定する  明確な期待が設定すると結果がわかりやすくなる       期待に応えない人をどうするかというのが一番難しい問題  立ち去ってもらうことがチームにとって一番良いこと       人間の問題を無視する  人間的な側面を無視してしまうととんでもないことになる ちょっとした共感さえあればよかったことがしょっちゅうある   みんなの友達になる  友人関係のままであろうとするな  友人関係も失うことになる  上下関係があると人工的な友人関係を作りだしてしまう可能性がある     友人関係とチームをリードすることとを混同してはならない 友人関係ではなく、不安を感じさせずに仲良くしたいなら、一緒にランチしろ   採用を妥協する  採用基準を満たす人を取れ 採用すべきでない人の採用のコストは高い   チームを子供として扱う  子供・囚人として扱うことは、信頼していないということ  これのコストは馬鹿高い   信頼されていることを感じれば責任を感じるようになる    リーダーシップパターン  エゴをなくす  謙虚になること  犠牲になることではない 自信がないことでもない   チーム全体のエゴやアイデンティティを育もう 方法:  チームを信頼すること  リーダーの仕事:  チームの合意形成や方向性の決定を支援  質問を歓迎し、オープンに受け止める     リーダーの仕事ではないこと:  全てに正しく 全てを知り 全てに応える 達成方法はプロダクトを作る人が決定すべき     ミスをしたときに謝ること  心から謝罪するということ  分別があり、状況判断が得意で、ＨＲＴのＨを備えた人と思われるようになる         禅マスターになる  多くのエンジニアが懐疑的や批判的な感度が高いと思われる  チームリーダーとしてはそういった言葉を慎め   常に平静を保つ  そうでないと部下に大きな悪影響を及ばす   問題解決モードに突入する前に、質問者の問題解決を助けるために支援をする  そのために質問をする     触媒になる  合意の形成を行う。  方向性を示したり、決定したりする   妨害や障害の除去・回避  適任者へ連絡する 適切な答えを知るよりも、適切な人を知る方が価値がある   安心感を与え、リスクを取れるようにする  リスクをとれば大きな成功の確率が上がったり、道が開けたりする 失敗してもいいことをチームに知らせる  失敗によって多くのことを素早く学べる   個人の成功はみんなの前で称え、  失敗はチームとして受け止め、そこから学ぶ プライベートで建設的な批判をする       先生やメンターになる  自力で学ばせようとするのがリーダーの大切な役目  学ばせること:  技術 コード チーム文化、 想定される責任レベル     メンターに必要な三つのこと  チームのプロセスとシステムの経験 誰かに教える能力 相手がどれだけ支援を必要としているかを把握する能力     目標を明確にする  チームメンバーが同じ方向に行かねばならない ミッションステートメントを見せる  あとは、自律性に任せて、定期的に確認 これで、チームの効率は劇的に向上する     正直になる  褒め言葉のサンドイッチを避けた方がいい 本当に伝えたいメッセージを、正しく伝わっていることが重要  建設的な批判をするときは、親身になって共感すればいい 失礼のないように明確に 相手を防御的にするような伝え方はしない     幸せを追い求める  リーダーとして長期にわたって生産的に、かつ、離脱者を少なくするには、時間を作って、チームの幸せを計測すればいい 一対一の面談の後に「何か必要なものはある？」と質問する オフィスの外におけるチームの幸せにも注意を向けた方がいい  どうして生産性が高いのか低いのかが、プライベートな状況にまで目を向けているか、わかるかも   暗黙的な目標を明確化する   他のリマーク  移譲せよ、ただし手を汚せ  誰もやらないような仕事を担当してみる   自分自身を置き換えようとする 事を荒立てる時を知る カオスからチームを守る  チームの外側のカオスと不確実性と狂気がある   新しいことをやりたいなら取返しがつくかどうかを見極める チームを空中援護する いいところをフィードバックする    人を画一で捉えるな  人は植物(みたいにみんなそれぞれ必要なものが異なる)  必要なものは人それぞれ 「興奮/退屈」と「自発的/注意散漫」のマトリックス  自発的/注意散漫には、方向性が必要  何をすべきかを理解し、構造化のスキルを身につけ、管理可能なタスクに分割すればいい   興奮/退屈には、モチベーションが必要  モチベーションには二種類あり、一つは外発的 もう一つは内発的動機  自律性  方向性は与えられているとして、 自分で考えて行動をする  これはプロダクトオーナーシップを感じる     熟達  新しいスキルを学び、既存のスキルを向上させるための時間をもつこと  これにより、鋭く、効率的で、効果的になる     目的  プロダクトに対するフィードバックには目を光らせる            4章(チームの外部とのやり取りでHRTをもつ) 有害な外部とのやりとりの仕方  チームの外部の人たちとどうやり取りすればいいだろうか  チームのが文化を破壊するアウトサイダーから身を守る方法を学ぶ   有害とは  ある種の振る舞いのことである チームの文化に含めないこと・やりたくないこと  これらを明確化しておいた方がいい  明確化しておくと、目に余る振舞いの特定とその批判ができるようになり、 有害な振る舞いを排除する文化を作れる     人が変わっても文化は残る  強い文化は自己選択的である 文化を強くし、残すため、そして、悪い方向に行かないようにするためには、すでに記述した強くする方法のおさらいをしよう     脅威を特定する  特にリスクが高いのはチームの注意と集中であり、これは数少ないリソース  HRTのない、意図的にいじわるするような、トロルがやってくる そのような人が出てきたときに、取扱注意とこころにとめられるようにしよう   古典的なパターンをいくつか  他人の時間を尊重しない  文書を読まない人だったりして、 人のエネルギーを消費する   エゴ  合意の決定を受け入れられない人 異なる視点の意見に耳を傾けられない人 妥協できない人  正しさよりも結論にたどり着くかどうかが重要     権利を与えすぎる  要求すれど貢献はしない人たち 権利を与えすぎるとトロルになる   未熟なコミュニケーションと複雑なコミュニケーション  本名を使わなかったりメディアによってニックネームを分けたりする  (日本のインターネット文化とはだいぶ異なる)     パラノイア  オープンで透明なコミュニケーション文化があったとしても、 陰謀論を唱える被害妄想患者がいる   完璧主義者  プロジェクトを停滞させる       脅威を追い出す  振る舞いを追い出す  人の追放は必然的な結論ではない  (振る舞いの追放は結局人の追放に繋がるのでは？という意見があった。確かに、実際に追放したり、追放に繋がることは多いだろうが、そういう振る舞いをする人が勝手に消えてくれるのは追放したのではなく自己選択してくれた結果、ということになるであろう)     いくつかの方法  完璧主義者には別の方向性を与える  完璧主義の対象となるテーマを変更する 不平不満をいう人にも効果的で、テストや手戻りの確認を担当してもらうなどがある   トロルには黙殺し、餌を与えない  (これ、とても難しいし、無視することがコストではないか、という意見もある。)   感情的にならない  仕事は優れたソフトウェアを書くことであり、 ご機嫌をとったり、正当化したりすることではない 争いごとはきちんと選んで、平静にたもつようにしよう   不機嫌の真実を探せ  積極的に事実を探そう  指摘されたことを好意的に解釈し  悪口の部分を全部無視して   真理をついているか、その人の経験から学べるか、などを確認する     優しく追い出す  平静を保って事実を見るのを応用するとできる   諦める時をしる  どんなに振る舞いを直そうと頑張ってみても 見込みがないと諦めて先に進まなければならないときがくる   長期的に考える  有害な振る舞いに対応するときの2つの質問  短期的にはチームの注意や集中を無駄にしても、長期的にはプロジェクトにメリットがあるか？ その衝突は有益な方法で解決できるだろうか   短期的なメリットのために文化を妥協する必要はない  HRTの重要性を認めない頭のいいコントリビューターには気をつけろ 技術的に貢献できる人は交換可能であり、 ポリシーを崩すわけにはいかない     ハンロンの剃刀  無能(無知)で十分説明されることに悪意を見出すな     人を追い出すのが仕事ではない。仕事は  破壊的な振る舞いを受け入れず HRTに対する自分の期待を明確にすること      5章(チームが所属する組織とのやり取りでのHRT)  組織的操作  組織をうまく進める方法  小手先のテクニック 社内政治とか、ソーシャルエンジニアリングとか呼ばれる   うまく機能している会社  2つのレベルで機能している  マネージャー  HRTのあるサーバントリーダーであり、成功を支援してくれる   組織   ここでのやることは  自分の責任範囲を広げよう  先を見越した行動や責任を自ら求める振舞い   リスクをとろう  早めに失敗しよう 失敗したときは自分で責任をとろう   大人らしく振舞おう  自分が期待していることを他人に伝える   質問しよう  納得いかない決定があればその根拠について質問したり議論したりすることを恐れてはいけない   マネージャーはエスパーではないから伝える  何をしているか聞かれる前に何をしているかを報告しよう  うまくいったことや、障害物があることや、何かを期待していることなど         理想的な組織ではなかった場合は？ 環境が成功を邪魔している  悪い人  悪いマネージャー  自分のキャリアしか考えていない人  失敗に対する不安 外部とのやり取りへの不安 知の独占     オフィスの政治家  こいつを信頼するとキャリアに制限がかかる すぐ他人のせいにし、自分の手柄にしようとする 見分け方:  影響力のある人を探そうとしていることですぐわかる       悪い組織  会社の経営に口を割り込ませないような組織 封建制度のような指揮統制型の構造 肩書や組織階層のことで頭がいっぱい 言うことを聞かない子供のように扱われている 成功の評価が見当はずれ 集中・ビジョン・方向性などの重要な要素がない     組織操作  振舞うべきことは多くあるが、 そういうものと認めよう ルールは変更できる  利用できる仕組みを見つけて、居心地のいい場所を作ろう なお、抵抗や正当化には、政治資本が必要となる     戦略  許可を求めるより寛容を求める方が楽  組織で許されていることの把握 アイデアに共感する仲間を見つけ、セカンドオピニオンをしてもらう   道がないなら道を作る  草の根でアイデアを受け入れてもらう・広める  (誰から聞いた言葉かは忘れたが、「壁にひざまずくのではなく、壁を打ち砕くのではなく、壁をすり抜けよう」という言葉を思い出した。)     上司の管理方法を学ぶ  何をやっているか表明する   約束は小さくして、届けるものは大きく  できないものに「No」と言う意味で約束を小さく プロダクトのローンチをするという意味で届けるものを大きく プロダクトのローンチにエネルギーを注ぐべき  「攻撃的」な仕事と「防御的」な仕事  政治的信頼性の獲得をしやすい攻撃的な仕事、UI改善や新規機能開発 防御的な仕事というのは生産性をあげるためのリファクタリングなどの負の遺産の整理である。 筆者らは、3分の1から2分の1までしかかけないようにしており、それ以上は政治的自殺行為であるから、と述べている。  (なお、私がここまで防御的な仕事になったのは、昨年外部と関わった仕事で、内部の攻撃的な仕事に関われなかったことがきっかけなのかもしれない。)         運と親切の経済  他人の仕事を手伝うようにするという親切を掛け金として 見返りが来たり気づきが得られたりという運が入り込んでくる  それによって人のつながりが得られ、それは会社から抜けた後でも続く     安全なポジションまで昇進する 強力な友達を探す  コネクタ 引退選手 管理スタッフ 君自身   忙しい経営者にお願いする方法  問題の説明については、最大3つの箇条書きと 1つだけの行動要請でもって  HRTの原則に基づいたお願いや質問をすること 問題の詳細等については、お願いやメールの締めの後に、追加する。       逃げる  正しいことをして、後は、解雇を待つ 自分自身の将来をコントロールできる能力を身につける。      6章(ユーザーとのやりとりにHRTの原理を持ち込む) ソフトウェアの目的と生存のためにすること  ソフトウェアを書く理由は、他人が幸せにすること。 だから、  他人が幸せにならなければ、 feedback loopの方法を身につけなければ、 ソフトウェアは死ぬ。    User Engagement  ユーザーの気づき(マーケティング; どのように見られているかに気を配る) ユーザーの体験(ユーザビリティ; ユーザーが離れるのを避ける) ユーザーとのやり取り(顧客サービス; 長期的な関係構築が、ソフトウェアの進化とユーザーの定着に影響を与える)   マーケティングは、エンジニアリング文化で重要視されている事実ベースと相性が悪いが無視できないが、うまくやる方法がある  感情的な知覚に配慮する  認知したもの勝ち   第一印象に注目する 小さく約束し、大きく届ける(見積もりを大きくしたり、予告をしなかったり) 業界のアナリストとうまく付き合う   ユーザーに集中すれば、他のことは全てついてくる  これが、プロジェクトの成否にも関わる 観客を選ぶ  最重要なのは、ユーザーの技術的能力を考える   入り口のハードルを下げる  最初の体験が超重要。 アカウント作成を強要しなかったり、スピードを優先したり、と。   ユーザーではなく、利用を計測する 速度重要  速度は機能ですらある。(非機能要件とよく言われるが、Googleの人は機能要件と捉えているようだ) レスポンスが速ければ、待ち時間が短くなり、何度でも使うようになる  無意識により多く使うようになる   利用数の停滞の原因は、多くは速度・スループットにある。   多くのユーザーの共通の問題を解決する ユーザーにとって使いやすいソフトウェアを作るためにはなまけないこと 複雑さを隠す  複雑さを隠し、簡単なことをしているように感じられるようにする、つまり抽象化する(インターフェイスの柔軟さ)  しかし、ユーザーを不自由にしてはいけない  抽象化が漏れる場合のバイパスを用意すること   ユーザーの信頼を得ることが最も大切なリソースである  これのために、インターフェイスの回避を用意すること         ユーザーとの関係の管理  ユーザーは話や自分の意見を聞いてもらいたく、関係を築きたいと思っている  話や意見の存在や内容を認知することが重要 ユーザーはHRTのある会社なら好きになる   ユーザーと開発者との間に壁を作ってはならない  ユーザーの増加は技術能力の平均レベルの低下を招き ユーザーの失望を増やし 苦情の増加を招く けれど、その苦情を開発者に届けさせないことはダメなことだ。   見下さない  ユーザーの質問や意見はユーザーの知能とは関係ない ユーザーに敬意を払おう   我慢する  ユーザーは問題をうまく表現できない  語彙の統一がされていないという問題がある     信頼と喜びを作ろう  信頼  おおよそ感情的に正の状態が積み重なった結果のもの すぐ吹き飛ぶ 最も大切なリソース  残高に気を配ろう 長期的なイメージを持とう     喜び  幸せな気分にさせる驚き  ユーザーを大切にしていることを伝える          まとめ HRT、これの欠乏が問題を引き起こす\nHRTの原理を、『Team Geek』では、以下のように広げていった。\n 自分 チーム チームをリードする方法 チームの外部とのやり取り ユーザーとのやり取り  この手法は、エンジニアリングのみならず、あらゆるコミュニティが対象となる。\n"},{"ref":"https://2222-42.github.io/2020/11/15/20201115log/","title":"20201115log","section":"post","date":"2020.11.15","body":"今日は休息の日とした\ndiary rest 休むことは良いことと自分に言い聞かせる。\nhat 帽子が欲しい。Jewish Hatが欲しい。\n昨日、西武に行ったら対して良さげでもないものが、3万超えていた。やはりユダヤ教徒が普段使う落ち着いた帽子が丁度良いと思う。\n今日の勉強 team リーダーシップパターン\n エゴをなくす  謙虚になること  犠牲になることではない 地震があにことでもない   チーム全体のエゴやアイデンティティを育もう 方法:  チームを信頼すること  リーダーの仕事:  チームの合意形成や方向性の決定を支援  質問を歓迎し、オープンに受け止める     リーダーの仕事ではないこと:  全てに正しく 全てを知り 全てに応える 達成方法はプロダクトを作る人が決定すべき     ミスをしたときに謝ること  心から謝罪するということ  分別があり、状況判断が得意で、ＨＲＴのＨを備えた人と思われるようになる         禅マスターになる  多くのエンジニアが懐疑的や批判的な感度が高いと思われる  チームリーダーとしてはそういった言葉を慎め   常に平静を保つ  そうでないと部下に大きな悪影響を及ばす   問題解決モードに突入する前に、質問者の問題解決を助けるために支援をする  そのために質問をうる     触媒になる  合意の形成を行う。  方向性を示したり、決定したりする   妨害や障害の除去・回避  適任者へ連絡する 適切な答えを知るよりも、適切な人を汁方が価値がある   安心感を与え、リスクを取れるようにする  リスクをとれば大きな成功の確率が上がったり、道が開けたりする 失敗してもいいことをチームに知らせる  失敗によって多くのことを素早く学べる   個人の成功はみんなの前で称え、  失敗はチームとして受け止め、そこから学ぶ プライベートで建設的な批判をする       先生やメンターになる  自力で学ばせようとするのがリーダーの大切な役目  学ばせること:  技術 コード チーム文化、 想定される責任レベル     メンターに必要な三つのこと  チームのプロセスとシステムの経験 誰かに教える能力 相手がどれだけ支援を必要としているかを把握する能力     目標を明確にする  チームメンバーが同じ方向に行かねばならない ミッションステートメントを見せる  あとは、自律性に任せて、定期に敵に確認 これで、チームの効率は劇的に向上する     正直になる  褒め言葉のサンドイッチを避けた方がいい 本当に伝えたいメッセージを、正しく伝わっていることが重要  建設的な批判をするときは、親身になって共感すればいい 失礼のないように明確に 相手を防御的にするような伝え方はしない     幸せを追い求める  リーダーとして長期にわたって生産的に、かつ、離脱者を少なくするには、時間を作って、チームの幸せを計測すればいい 一対一の面談の後に「何か必要なものはある？」と質問する オフィスの外におけるチームの幸せにも注意を向けた方がいい  どうして生産性が高いのか低いのかが、プライベートな状況にまで目を向けているか、わかるかも   暗黙的な目標を明確化する   他のリマーク  移譲せよ、ただし手を汚せ  誰もやらないような仕事を担当してみる   自分自身を置き換えようとする 事を荒立てる時を汁 カオスからチームを守る  チームの外側のカオスと不確実性と狂気がある   新しいことをやりたいなら取返しがつくかどうかを見極める チームを空中援護する いいところをフィードバックする    isabelle 証明すること:\nfold c empty ~ c 求められること：\n  empty tableから任意のtableに一般化する\n  tに対するside conditionの追加\n  conditionを除いてコマンドが等しい\n commandの等しさは、  全てのstateではなく、 preconditionを満たすstateについて、 実行が一致することが求められる      equiv_up_to:\np |= c ~ c' = ALL s s'. P s --\u0026gt; (c,s) =\u0026gt; s' = (c', s) =\u0026gt; s' bequiv_up_to:\np |= b \u0026lt;~\u0026gt; b' = ALL s . P s --\u0026gt; bval b s = bval b' s "},{"ref":"https://2222-42.github.io/2020/11/14/20201114log/","title":"20201114log","section":"post","date":"2020.11.14","body":"コーヒー飲んでずっと人を待つということをやっていた\ndiary coffee 皇琲亭でブレンドコーヒーとストレートを2種類飲んだ。\n久しぶりに行ったが、あの雰囲気はよかった。\n後、1杯飲むなら高いが2杯以上だとちょうどよい値段になる。\nfriend 友達に対する興味が一瞬で消えた。\nあんなに強い興味があったのに。\n原因はなんだろうか、相手が1時間半も遅刻したからだろうか。\n今日の勉強 rust pp.118-128\n6章\n if let記法  ifとletをより徐儒調整の少ない方法で組み合わせ 残りを無視しつつ、1つのパターンにマッチする値を扱うことができる  match式だと追加すべき定型コードが多すぎる matchで強制される包括性チェックを失う やりたいことと、関係性を得ることが包括性チェックを失うのに適切な代償となりうるかによる      if let pattern = formula { code } else { code } memo:\n 借用と参照にまだ慣れていない  まとめ:\n enumを使用してワンセットの列挙された値のどれかになりうる独自の型を生成  Option\u0026lt;T\u0026gt;でエラーを回避できる   enumの値がデータを乃武に含む場合、処理すべきケースの数に応じてmatchかif letを使って、値を取り出し使用できる Rustが型安全性を保証する  Compilerが各関数の予期する型の値のみを関数が得ることを確かめてくれる    7章\n コードのまとまりをよくする  関係した機能をまとめ、異なる特徴をもつコードを分割  見つけたり、変更したりするために、どこを探せばよいかを明確にできる   プログラムの整理  複数のファイル・複数のモジュールに分割 パッケージは、複数のバイナリクレートからなり、またライブラリクレートを最大1つもつことができる  一部を分離したクレートにし、外部依存にするのもよい       機能のグループ化 + 実装の詳細のカプセル化  より高いレベルでコードを使える  実証の詳細を知ることなく、手続きで、そのコードを呼び出せる   コードの公開・非公開も書き手によって決定される  プログラマが記憶しておくべき細部の制御をできる     スコープ  「スコープ内」として定義される名前の集合  同じ名前の者を2つの同じスコープ内には持てない 特定の名前 -\u0026gt; どの要素か -\u0026gt; 何を意味するか     モジュールシステム  コードのまとまりを保つためのたくさんの機能  公開・非公開、スコープ内外の管理等     クレート  バイナリクレート ライブラリクレート 関連した機能を1つのスコープにまとめる ライブラリか実行可能ファイルを生成する木構造をしたモジュール群 関連した機能を1つのスコープにまとめることで、その機能が複数のプロジェクト間で共有しやすいようにする  クレートの機能をそれ自身のスコープの中に入れたままにする  名前の衝突を予防する       クレートルート  Rustコンパイラの開始地点 クレートのルートモジュールを作るソースファイルのこと   パッケージ  ある機能群を提供する1つ以上のクレート クレートをビルドし、テストし、共有することができるCargoの機能  Cargo.tomlがそれらのクレートをどのようにビルドするか説明するファイル  Cargoがクレートルートファイルをrustcに私、ライブラリやバイナリをビルドする  main.rsやlib.rsについて、パッケージ名と同じ名前を持つクレートルートであるという慣習があるので、Cargo.tomlでは省略できる src/binディレクトリに置けば、複数のバイナリクレートを持たせることができる       規則がある  パッケージは0か1個のライブラリクレートを持つ バイナリクレートはn個持ってよい 少なくとも1つのクレートを持つ必要がある     モジュール  クレート内のコードをグループ化し、可読性と再利用性を上げるのに役立つ  関連する定義を1つにまとめ、関連する理由を名前で示せる  グループ単位でコードを読める 新しい機能を追加するときはどこに置けばよいか分かりやすい     プライバシーも制御できる  コードの外側で使える(public) 内部の実装の詳細であり、外部では使えない(private)   クレートルートと呼ばれる理由  モジュールツリーと呼ばれるクレートのモジュールの根っこ(ルート)にmain.rsとlib.rsの中身がcrateというモジュールを形成するから 親子関係やディレクトリ構成によく似ている   要素を見つけるためにどこを探せばいいのかを教えるためにパスを使う    mod name { mod struct enum const fn }  パス  絶対パス  crate::xxx::yyy クレートルートからスタートする   相対パス  (self/super::)xxx::yyy 現在のモジュールからスタートする   使い分け方  プロジェクトによって決める 要素を定義するコードを、その要素を使うコードと別々に動かすか一緒に動かすか、どちらが起きそうか  両方動かすなら絶対パスを更新する必要があり 関数だけ動かすなら相対パスを更新する必要がある       プライバシー境界の設定  外部のコードが知ったり、呼び出したり、依存したりしてはいけない実装の詳細をカプセル化する線引き  関数や構造体を非公開にしたいならモジュールに入れればよい   標準で非公開という選択をRustはとっている  内部コードのどの部分が外部のコードを壊すことなく変更できるかを知れる   親モジュールの要素は子モジュールの非公開要素を使えない  子モジュールは実装の詳細を覆い隠す   子モジュールはその祖先モジュールの要素を使える  子モジュールは自分の定義される文脈を見ることができる     "},{"ref":"https://2222-42.github.io/2020/11/13/20201113log/","title":"20201113log","section":"post","date":"2020.11.13","body":"22時に寝るようにするためにブログを簡略化することを決めた。\ndiary health 健康的な肉体と精神を獲得するために、22時から2時までの睡眠が重要らしい。\nそのため、日課を調整し、22時には眠れるようにしなければならない。 だから、このブログも簡略化する。\n適当に書いてビルドして、また後日修正する、というのを繰り返すようになると思う。\ncommunciation 2人の会話でのそれぞれの姿勢の違いで、周囲の人へのイメージが大きく異なる。\n目に止まっていたので、文句を後で伝えた。うまく伝わったかはわからない。\ntask management まじで残タスクが多すぎてカバーしきれず、思い出してうわあっとなることが多い。\nISSUEで記録取ってトラッキングしててよかった。\n今日の勉強 rust pp.114-118\n マッチのアームの別の有益な機能  パターンにマッチした値の一部を束縛できる  enum列挙子から値を取り出すことができうｒ enum列挙子(値) =\u0026gt; {...値...}     matchを使って、Option\u0026lt;T\u0026gt;を使うこともできる  値を比較す代わりにOption\u0026lt;T\u0026gt;の列挙子を比較する matchとenumの組み合わせは多くの場面で有効  enumに対しmatchし 内部のデータに変数を束縛させ それに基づいてコードを実行     Rustのmatchは包括的  全可能性・パターンを網羅していないことをコンパイラが検知し、エラーを検出する   プレースホルダー(_)  このパターンはどんな値にもマッチする  他のアームの後に記述することで_はそれまでに指定されていない全ての可能性にマッチ  (defaultっぽさがあるかちょっと違うような気がする。)     1つのケースにしか興味がない場合はif letを使え。   "},{"ref":"https://2222-42.github.io/2020/11/12/20201112log/","title":"20201112log","section":"post","date":"2020.11.12","body":"なじみのBarがまた消えた話。\nrustのOption型に関する勉強メモ。\ndiary bar また一人のバーテンがなじみのバーからいなくなる。\nバーに行くことの楽しみは、その雰囲気やその人との会話を楽しむことである。 ゆえに人がいないことはそのバーが消えたようなものである。(斧の刃を変えるのとは違う。)\n人がいなくなればそれだけそこに行く理由がなくなる。\nalopecia areata あごひげの一部に円形脱毛症が発生した。\n病院に行って、相談してみる。\n今日の勉強 rust pp. 110-114\n enum  プログラムにデータ以上の情報をコードかできる Option型  値が何か、そうでないか 値が存在するか不在か(有効でないか)という概念をenumでコード化する   Rustにはnullがない  nullのある言語では、変数は、常にnullかそうでないかの二者択一 nullの表現しようとしている概念  何らかの理由で現在無効または存在していないこと   この概念ではなく特定の実装に問題がある  何らかの種類のエラーが出る     Option\u0026lt;T\u0026gt;と、Some(T)、Noneも初期化(prelude)に含まれている  明示的にスコープに導入する必要がない  つまり、SomeとNoneの前にOption::の接頭辞なしで使える   \u0026lt;T\u0026gt;: ジェネリック型 Noneを使う場合は、Option\u0026lt;T\u0026gt;と型注釈をしなければならない  なぜなら、Some列挙子が保持する型をNoneだけからは推論できないから     Option\u0026lt;T\u0026gt;と\u0026lt;T\u0026gt;とは型が異なる  Option\u0026lt;T\u0026gt;値を確実に有効な値かのようには使用できない  なぜならコンパイラにはその使用方法が分からない   Tの型の値  Compilerが常に有効な値かを確認する  値がnullではないと安全に想定できる   常に自信を持って先に進める   Option\u0026lt;T\u0026gt;がるとき、  この時のみ、値を保持していない可能性を心配する必要がある コンパイラはプログラマが値を使用する前にそのヨナ場面を扱っているか確認する nullになる可能性のある値を保持することにこの型を使うことで明示的に同意することになる   実際にはnullなのにおうではないかのように想定することへの問題  T型の処理を使う前には、Option\u0026lt;T\u0026gt;からTに返還する必要がある  Some列挙子の値をどのように取り出せばよいか  ドキュメントを読め  .unwrap()とか.unwrap_or(default_value)とかがある           各列挙子を処理するコードが欲しい時はmatch式を使おう(フロー制御文法要素となる)  enumの各列挙子によって違うコードが走り そのコードがマッチした値の中のデータを使用できるようになる     matchフロー制御  match: フロー制御演算子  一連のパターンに対して値を比較し、  最初に適合するパターンで   マッチしたパターンに応じてコードを実行する   match式のパワーの由来  パターンの表現力と コンパイラが全てのありうるパターンを処理しているか確認してくれる事実      match 式 { pat =\u0026gt; code, pat =\u0026gt; code, ... } 補足:\n 式はifの時とは異なり、任意の型でよい =\u0026gt;は区切り演算子 区切り演算子の左がパターン  パターンは上から順に比較される。   区切り演算子の右が何らかのコード(マッチアーム)  codeは式であることが要求される マッチしたアームの式の結果がmatch式全体の戻り値になる マッチのアームで複数行を走らせたいときは{}でブロックを作ればよい   "},{"ref":"https://2222-42.github.io/2020/11/11/20201111log/","title":"20201111log","section":"post","date":"2020.11.11","body":"コミュニケーションが下手であることを自覚することのメリット。壁に立ち向かう時の心構え。\nRustの構造体や列挙型に関するメモ、Isabelleの定数畳み込みと定数伝播に関するメモ、チームのマネージャー・マネージメントに関するメモ。\ndiary communication 日々繰り返し、このブログで、コミュニケーションについて語っているが、ふと周りを見ると、いくつか気づいたことがある\n コミュニケーションについてそれほど真剣に悩んでいる人が少ないこと コミュニケーションがたいていの人が下手、もしくは下手なことに無自覚  お願いと相談の区別すらつかない 同僚を子供か囚人のように扱っている人がいる   コミュニケーションをあえてやろうと挑む人が少ない  コミュニケーションをうまくやろうとする人が少ない？    だからと言って自分のことが免罪符になるわけではないが、 自分は、自分がコミュニケーションが下手であることに気づき、どうすればよいか悩み、開発にはコミュニケーションが必要不可欠だから敢えてやらねばならない、そしてうまくやらねばならないと活動しているのだなぁと気づいた。\nhow to handle wall(barrier) 壁に対してどう立ち向かうか、というたとえ話をふと思い出した。 (どこ出典かわからない。ググってもヒットしなかった)\n 壁の前で跪くか 壁を打ち砕くか 壁をすり抜けるか  これがどういう話だったのかを思い出せないのだが、自分で今これを解釈するのであれば、 壁の前で跪くユーザーに寄り添い、壁を打ち砕かんとする創業者に耳を傾け、エンジニアは壁をすり抜けろ、ということになるのであろう。\n今日の勉強 rust pp.100-110\n5章\n implの関数(メソッドの話をしている)には、自動参照および参照外しがある  C++のようなオブジェクトに対して直接でもオブジェクトのポインタに対しての区別をユーザーが行うのは不要である コンパイラがオブジェクトのシグニチャに合致するように自動でオブジェクトに以下のいずれかを付与する  \u0026amp;で読み込みのみか \u0026amp;mutで書き込みもか *で所有権を奪うか   selfを自明な受けてという  これのおかげで自動参照及び参照外しが有瀧   メソッドの受け手に関して借用が明示されない、というのが、所有権を実際に使うのがRustにおいて簡単である大きな理由   implの関数で、複数の引数(self以外に追加する)にすることができる 関連関数  implの別の有益な機能  selfを引数に取らない関数 関数でありメソッドではない  なぜなら対象となる構造体のインスタンスが存在しないから   e.g., 新規インスタンスを返すコンストラクタなどがある :: という記法を使う。  この記法は関連関数とモジュールによって作りだされる名前空間両方に使用される。       1つの構造体に対して複数のimplブロックを作れる  分けることが有用になるケースは10章で扱うジェネリック型とトレイトの議論の中で表れる   まとめ  構造体: 自分の領域で意味のある独自の型を作成できる その使用: 関連のあるデータ片を相互に結合させたままにし、各部品に名前をつけ、コードを明確にする メソッド: 構造体のインスタンスが行う動作を指定する 関連関数: インスタンスを利用することなく、構造体に特有な機能を名前空間分けすることができる。    6章\n 列挙型(enum)  取りうる値を列挙することで型を定義させる  取りうる値を全て列挙できる  どちらか一方の値で、同時に両方にならない場合に役立つ     代数的データ型に酷似している enumの値は列挙子のいずれか1つにしかなりえない  列挙子というのは、enumの要素のことである。 列挙子は種類の語り方のみであり、値の保存を考えることは必須ではない。      enumの書き方:\nenum 列挙型名 { xxx, yyy, }  enumの値  型::列挙子で各列挙子のインスタンスを生成する  型は一緒なので、それぞれの列挙子に対して、異なる関数は作らなくてよい   enumを使えば、構造体より簡潔な方法で、表現することができる場合がある  enumの各列挙子に直接データを添付することができ、 列挙子に紐づけるデータの型と量は異なっても良い  これが構造体ではできないこと いかなる種類のデータでも格納できる  列挙型も入れられる       構造体との類似点:  異なる種類の構造体定義を定義すること  ただし、enumの方が、構造体よりも、関数を簡単に作ることができる場合がある   implが使えるということ      team  リーダーのいないチームは機能しない  かじ取りする人のいない船みたいなもの ソフトウェアの方向性に影響を与えるためには、エンジニアリングリーダーシップを隅々まで理解する必要がある   マネージャー  誕生  産業革命期 労働者を監督するマネージャーという立場  労働者を人参と鞭とで管理していた 今ではもう全く効果がない     変化  エンジニアは数か月間かけて新しいチームに追いつく 考えたり創造したりするためにの育成・時間・空間が必要   違い  昔のマネージャー  親と子の関係のようなもの どうやって仕事を完了させるかを考える   リーダー  HRTでエンジニアを信頼するようにすれば、エンジニアはその信頼に答える チームのための道を作り、安全と安心に気を配る 何ができるかを考える  どうやって完了させるかはチームが考える       二種類のリーダーがGoogleにはある  TL(Team Lead): プロダクトの全部・一部の技術的な方向性に責任を持つ TLM(Technical Lead Manager): TLの責任に加え、チームにいるエンジニアのキャリアや幸せという、人の管理にも責任を持つ     Managerになることへの不安  コードを書く時間が減ることへの不安  定量化できないものが増えることへの不安  チームの幸せと生産性をたかめるのが仕事の指標である     無能なマネージャーになるのではないかという不安  ピーターの法則で、階級制度があるところでは、必ずその人の無能レベルまで昇進する     Managerになるべき大きな理由  自分をスケールできるから マネージャーに向いているかもしれないから  実際、マネージャーに向いていた人が多くいる     マネジメント病(管理したがり病)の負の再生産の問題について  サーバントリーダーシップで治療する  チームに奉仕すること HRTの雰囲気づくりをすること  アドバイスを与えたり、 順調に進めるよう穴を埋めたり 自らの手を汚す   技術的な側面とチームの人間関係の両方を扱う      マネジメントのアンチパターン\n 言いなりになる人を採用する  仕事が増えるぞ むしろ、自分より球が良くて、代わりになる人を採用しよう  新しいチャンスを産む     パフォーマンスの低い人を無視する  数名でもパフォーマンスの低い人がいるだけでチームはうまくいかなくなる 「願いは戦略ではない」  パフォーマンスの低い人にはコーチングをする  HRTとともに マイクロマネジメントをする  小さい目標から大きな目標へ マイルストーンには明確な期待を設定する  明確な期待が設定すると結果がわかりやすくなる       期待に応えない人をどうするかというのが一番難しい問題  立ち去ってもらうことがチームにとって一番良いこと       人間の問題を無視する  人間的な側面を無視してしまうととんでもないことになる ちょっとした共感さえあればよかったことがしょっちゅうある   みんなの友達になる  友人関係のままであろうとするな  友人関係も失うことになる  上下関係があると人工的な友人関係を作りだしてしまう可能性がある     友人関係とチームをリードすることとを混同してはならない 友人関係ではなく、不安を感じさせずに仲良くしたいなら、一緒にランチしろ   採用を妥協する  採用基準を満たす人を取れ 採用すべきでない人の採用のコストは高い   チームを子供として扱う  子供・囚人として扱うことは、信頼していないということ  これのコストは馬鹿高い   信頼されていることを感じれば責任を感じるようになる    次はリーダーシップパターン\nisabelle pp. 156-159\n定数畳み込みと定数伝播の続き\n 定数値を保存するテーブルtが、runtime state sに漸近することの、approxの定義 arithmetic expressions のfoldの afold の正しさの証明  induction貼って、あとは自動  自動と書いているが、自分で書いたら、sledgehammerでサジェストされなかったので、 simp: approx_defしてsimplificationしたり、 subgoalの形を見て、splitをしたりした。  split: option.split split: option.split aexp.split     言語ごとのfailure semanticsを保存するように定数畳み込みの定義には注意を払え  Invalid programに対して、validな結果を返すようなものもあるから     arithmetic expressionsに限定しない定数畳み込みと定数伝播の実装  fold :: com =\u0026gt; tab =\u0026gt; com  基本的なアイディア  take a command take a table produce new command   sequential composition (fold c_1;;c_2 t)について考えないといけないこと  recustionに適用する fold c_2に対しては、c_1の実行結果でアサインされたものの新しいvalueを取り上げるべきである  この認識は、最適化の分析から得られる       foldの実装には補助関数defs :: com =\u0026gt; tab =\u0026gt; tabが必要  commandを実行した後の、既知の定数値と変数を記述するような新たなtableを生成する関数   primrec defs :: com =\u0026gt; tab =\u0026gt; tab  IFのケースでは、両方の枝で同じ値が割り当てられている確認して、そういうテーブルを作る  mergeという補助関数を使う   WHILEのケースでは、  永遠にループするかどうかを静的に解析できない  13章までいけばできるらしいが   だから、tableに追加できない tableに追加できないだけではなく、tableに初期に保存していたものと矛盾する可能性がある だから、loop bodyの中に含まれるassignment statementのleft-handの変数を全部取り除く必要がある。  lvarsという補助変数で、assignmentsのleft-hand側、つまり、変数の集合を取る 取り除くのには t|`S = \\lambda x. if x \\in S then t x else None  というものを使っている。       primrec fold :: com =\u0026gt; tab =\u0026gt; tabの実装ができる  IFのケースでmergeを使っている WHILEのケースでは、defsの場合と同様、loop bodyの中に含まれるassignment statementの変数を全部取り除く必要がある   primrecについて  原始再帰的関数のこと 参考書類  stackoverflow Isabelle Theory Primrec Paper       "},{"ref":"https://2222-42.github.io/2020/11/10/20201110log/","title":"20201110log","section":"post","date":"2020.11.10","body":"Samuel Becketの詩を思い出し、開発のために、上手な失敗を素早く失敗するためにどうするか、ということを考える。\nRustの勉強記録は、5.1節から5.3節にかけての、構造体に関して、その所有権とその実装例とそのメソッドについて。\ndiary better fail Samuel Becketの詩の１つのうちに ever tried, ever failed, no matter, try again, fail again, fail better というフレーズがあると覚えている。\nこれはコーディングやプロジェクトにおいても当てはまると思っている。それは、プロダクトから、チーム、個人、そして一定時間、問わない。\nプロジェクトにおいては、この期間でこれだけをやって、リリースして反応を見て、うまくいかなかったら(たいていうまくいかないし何か問題があるので)、その問題を分析して、原因を特定して、また次にトライして、と繰り返す。\nチームのコーディングにおいては、コードを書いてPR出して、レビューをもらって、ダメだったらそれを改善して、またRe-request Reviewして、と繰り返す。\nさらに、もっと短い時間で、一時間でこれだけやろうとして、けれどできなかったとなったら、自分の技術的に分からないところがあるのか、それとも、要件や成すべきことを把握していないか、それとも、想定よりも難しいことが存在していたことがわかる。そこから、また、それらのことを解決したり分割したりして、また予測して、やってみて、と繰り返す。\n挑戦して、失敗して、けれど失敗自体に問題はなくて、また挑戦して、失敗して、うまく失敗する。\n失敗は一つの選択肢である、というのはよく言った言葉である。 開発においての失敗というのは大凡何らかのコミュニケーション不足や伝達不足(ユーザーとプロダクトの間、チーム間、自己認識いずれにおいても)があることが原因であり、それに早く気づき、それを早く解消し、早く形にするためには失敗に気づき、次にまたコミュニケーションをすることが開発の成功に繋がることである。\nfriend 会いたい人と会う予定を立てることがとても楽しい。\nけれど、会いたい人が私と本当にこの予定を喜んでいるのか、不安になってしまうこともある。 しかし、それもまたこそばゆい喜びを産んでくれる。\n今はとても幸せであり、こういう友を得られたことはとても良い。 (これを喪失したときは、またとても悲しみを産むのであろう。)\n今日の勉強 rust pp. 93 -100\n5.1節\n 構造体データの所有権  フィールドの方は所有権のあるものを使う  例えば、所有権のあるStringを使い、\u0026amp;strは使わない 理由:  全データをそのインスタンスに所有してもらう必要があるから 構造体全体が有効な間はずっと有効である必要がある   他の何かに所有されているデータへの参照を保持させるにはライフタイムを使う      5.2節\n 単一の変数を使った実装から、タプルを使った実装へ、構造体を使った実装へとリファクタリングをしていく  単一の変数だと、引数に関連性があるのにそれを表現されないという問題がある  可読性と扱いやすさの問題がある 変数をグループ化する   タプルで実装すると、要素に名前がないので、計算が不明瞭になるという問題がある  データの意味をコードに載せたい   ラベル付けするのに構造体を使う  関数に渡すのは借用を用いる(\u0026amp;を用いる)  理由は、main関数で所有権を保つため     構造体を使う際に、デバッグ中にインスタンスを出力しフィールの値を確保したい場合  構造体なので、整形する方法が自明ではない、  {}の代わりに、{?}かpretty-printな{:?}を使う。  Debugを呼ばれる出力を使いたいと指示する   この機能を構造体で使うようにするのに、derive注釈をして、明示的に選択をしなければならない  (なお、これら一連のやるべきことはcompilerのError messageから何をやるべきかわかる)          5.3節\n メソッド記法  構造体と関数をより緊密に結びつける  他のどんな型でもうまく動作しなくする   メソッドについて  構造体(もしくはenumかTrait Object)の文脈で定義される 最初の引数は必ずself  selfはメソッドが呼び出されている構造体インスタンスを表す        メソッドの書き方は以下の通り:\nimpl 構造体名 { fn 関数名(self (もしくは \u0026amp;self)) { ... self.xxx ... } }  メソッドの使い方  インスタンス.関数名() メソッドの引数は、関数と同じで、所有権を奪えたり、不変借用したり、可変借用したりできる   メソッドの利点:  selfの型を繰り返し書く必要がなくなる 体系化できる  ライブラリ内の各所を探させるのではなく、 この方のインスタンスでできることを1つのimplにまとめられる。     "},{"ref":"https://2222-42.github.io/2020/11/08/20201108log/","title":"20201108log","section":"post","date":"2020.11.08","body":"昨晩のお酒が残っていて、今日も虚無な一日を送ってしまった。\ndiary alcohol 昨晩のアルコールのせいで、だいぶ眠っていた。\n蕎麦を食べて、お腹を休ませる\nfriend 昨日会った人は、久しぶりに、この人とまた会いたい、と思わせられる人物だった。\nなぜかはわからない。\n少なくとも、私は、その人との会話で幸福を覚えており、今日に至っても満足感がある。\nこの人がどんな判断をするか、とか、この人と同じ体験を共有したいと思った。\nHumidity 相手の判断について、私は、その判断をまず否定することをしなくなっている、ということに気づいた。\nだいぶ前は何事も「いや」という言葉からスタートしていた。 しかし、最近は疑問に思っても「そうなんですか？」とか「ちょっとわからないですね」という言葉からスタートするようになっている。\nこれで狭量が広いと判断されるようになっているのだろうか。\n少なくとも、相手の判断について、謙虚を私が抱きながら、接することできるようになったのだろう。\n今日の勉強 rust TRPL\n pp. 80-85 スライス型  所有権のないデータ型 コレクション全体というよりかは、そのうちの一連の要素を参照することができる。 コレクションの一部を参照しようとするときに問題になること  参照して、欲しい部分の添え字を取る 参照＋添え字で意味を成す 参照が可変なら変更され、全体の意味がなくなる 同期が取れないという不安が発生する   そこでスライスが生きる   文字列スライス  Stringの一部への参照  \u0026amp;s[starting_index..ending_index]  ..で範囲を取る  starting_indexからending_index未満の範囲   [と]とで、スライスを生成する  スライスのデータ構造は、以下の2つを保持している。  開始地点へのポインタと スライスの長さ     範囲添え字は有効なUTF-8文字協会に置かねばならない     文字列スライスを表す型\u0026amp;str 文字列スライスを使うことで、Stringへの参照が有効であることをコンパイラが保証してくれる  何かへの不変な借用があるときに、さらに可変な参照を得ることができないから。     "},{"ref":"https://2222-42.github.io/2020/11/07/20201107log/","title":"20201107log","section":"post","date":"2020.11.07","body":"香水の一番良いところはその香りであるよりも、その残り香であり、離れた後でもその人のことを思い出せることにある。\ndiary perfume 香水を上手に使う人はすごいと思う。 どうやっても、その人のことを思い出してしまうからである。\n意識的にドライにプロファイリングする時でも、その香りで判断が邪魔されてしまう。\nenginnering culture エンジニア文化はすごくドライというか、毎日勉強や訓練をすることや、リリースすることに追われてしまう側面があり、逆に人間的側面が軽視されがち。\nそれをエンジニア文化に属していない人からすればそれはすごく怖いところと思われがちである。\nしかしながら、人間的側面が必ずあるから、私はそこを補うために活動をしているということもまた、エンジニア文化の性質を知っている人からすると、なぜ敢えてドライな文化においてそういう人間的側面を敢えて重視し、評価されないかもしれないところのことをやろうとするのか疑問視される。\n人間的側面が必ずあり、そして、その人間的側面を補うことが、隣人に求められているからである。\nsummer school 今年の夏は京都に行けなかった。悔やまれている。\nまた、来年の夏もどうも行けなさそうである。それもまた後悔を産みそうであり、嫌だ。\n今日の勉強 rust TRPL\n pp. 73-80 所有権ではなく、引数としてオブジェクトへの参照を取る、つまり借用する関数がある  実引数には\u0026amp;s1 仮引数には\u0026amp;String  \u0026amp; が参照を指す  参照外し演算子は*       変数の値を参照する参照  変数の値を所有しない ゆえにその参照がスコープを抜けても、その値はドロップされない   借用した値の変更を試みるとコンパイルエラーが発生する  借用もデフォルトは不変   可変な参照  実引数には\u0026amp;mut s1 仮引数には\u0026amp;mut String   可変な参照の制約  特定のスコープの特定のデータに対しては、1つの可変な参照しか持てない。 データ競合が起きる条件は以下の3つであり、これらの条件が満たされる場合に、コンパイルさえしないならば、データ競合が発生しない。  2つ以上のポインタが同じデータに同時にアクセス 少なくとも1つのポインタが書き込みを行っている データへのアクセスを同期する機構が使用されていない。   新しいスコープを生成し、同時並行でなくせば、複数の可変な参照を作れる   可変と不変の組み合わせでも類似の規則があり  同じスコープ内で不変で借用した後に、可変で借用というのはできない  不変参照の使用者は値が変わることを想定していないから     宙に浮いた参照  ダングリングポインタ  他人に渡されてしまった可能性のあるメモリを指すポインタのこと  これはその箇所へのポインタを保持している間にメモリを解放してしまうことで発生する     Rustは参照がダングリング参照にならないように保証する  コンパイラは、参照がスコープを抜けるまでデータがスコープを抜けることがないよう確認する  もしそれをやろうとすると、ライフタイムパラメーターを使え、と怒られが発生する       参照の規則のまとめ  任意のタイミングで  以下のいずれか一方を行える  1つの可変参照か 不変な参照をいくつでも     参照は、常に、有効でなければならない    team 『Team Geek』の0章、1章、そして2章の途中まで読み直す。 メモを作りつつ、近いうちの会社での発表に向けて、準備する。\n プロジェクトの成功には以下の2つの要因が必要である  優れたコードという技術的要因と みんなの協力という人的要因  人間は難しく「人間は断続的なバグの大きな塊」 その一方で、チームは個人の生産性や幸福に直接影響する     天才の神話  天才はコードを隠さない  優れたコードだとしても不十分   コードを隠すのは不安の裏返しである 天才の本当の功績は、チームとうまくやることができたこと 1人でやることは失敗のリスクが高まる。みんなでやることのメリットが高い。  失敗に早期に気づける  プロジェクトには、高速でのフィードバックループが必要   プロジェクトののバス係数が高まる スケールできる   チームが全て   謙虚、尊敬、信頼、これを自分が持ち、相手も抱けるような環境を作ることの重要性。  HRT、これらが健全な対話とコラボレーションの基盤  これらが欠如すると人間関係が衝突する  人間関係は、プロダクトやプロジェクトより、長く続く   これらがあると、いざ困ったときに、助けられる   謙虚  エゴをなくす  コミュニティは信じられないほど強力なアイデンティティがある   自分の学習のための時間を作る   コードの指摘には謙虚になり、相手に尊敬を含め、相手が恩恵をもたらしてくれると信頼する。 失敗、学習、反復  不完全を見せても構わないという謙虚さを持ち、 ユーザーが、対応を賞賛し、改善を要望するという信頼で、 失敗の文書化(ポストモーテム)をする  何を学んだか、何を改善するか     忍耐を学ぶ 影響を受けやすくする  間違いや能力不足を認める  謙虚さを見せる   他人の意見を信頼する この正直さと強さは尊敬を産む     チーム文化を作ることで、自己選択的な文化になり、また、外部から来た悪意ある人や文化を排除することができるようになる。  文化はイースト菌のようなもの  そしてその種菌が重要   チーム文化とは、エンジニアリングチームが共有する、経験、価値、目標 まず優秀なエンジニアを雇う 強い文化は自己選択的な文化である  文化に合わない人は、事前に遠ざかってくれる   合意ベースのマネジメントなら、チーム全体が意思決定プロセスに参加できる  チーム全員がプロダクトの成功に強い責任を持ち リーダーがチームの意見に耳を傾けること(尊敬)   チームメンバーの接し方  HRTを持っていればよい 前向きな批判をしてくれる友達や同僚を見つけよう   文化が、積極的なのか、のんびりなのかを理解し、  新来者に支配されないように気をつけよう     コミュニケーションなしには正しいコードを書いている保証ができない。  同期コミュニケーションの人数を減らし 非同期コミュニケーションの人数を増やす    Isabelle Concrete Semantics\n Big Step Semantics with Error Propagationの定義を読む  久しぶりの Concrete Semantics なので、定義の趣旨を完全に忘れている。   Big StepにおけるDの健全性の証明を読む  Small Stepの場合に比べて、かなり単純になっている。 WhileTrueの場合の証明の部分で、command cに対する帰納法の適用を行っていることに気づくのが遅かった   "},{"ref":"https://2222-42.github.io/2020/11/05/20201105log/","title":"20201105log","section":"post","date":"2020.11.05","body":"窓口を明確にすることは本質を変えないが、楽にはしてくれる。\ndiary interface 窓口を作っても本質を変えるわけではないが、次の一手を探りやすくしてくれる。\n窓口やインターフェスを作ることは、伝えるためのフォーマットをこちらから相手に強制でき、かつ、相手は伝えたことを確証できるようにさせる。 これにより、「言ったのに！」とか「いや、伝わっていない」とか、もしくは伝え方におけるミスいう事象を排除できる。\nそもそも、複数のエージェント間で、お互いが特定の知識を持っており、そのうえで、お互いがその知識を持っていることを知っているという、共有知識が成り立つためには、なんらかのアルゴリズムが必要である(アルゴリズムがなければ共有知識は成立しないが、アルゴリズムがあれば共有知識が成り立つわけではない)\nしかしながら、フォーマットを策定して、伝え方がよくなり、そして、共有知識を確保したところであっても、次のアクションがなければ意味がない。\nもちろんその通りであるが、相手が定まった形式で伝えてくることで、どういう内容を伝えてくるのかが受け手にはわかりやすくなり、そして、どういう流れでそのあとの話を進めるかも手探りしやすくなるというメリットが、フォーマットの策定には意義がある。 (伝達でのミスを解消するためには誰かがハンドリングしないといけないが、その誰かをフォーマットにするのが楽である。(そのフォーマットに従わない邪悪な人は文化に従わせよう))\n人間のコミュニケーションが不完全であるから、1つずつやっていき、よりフィットするコミュニケーションのあり方を調べていく。\nsandwitches オフィス近くのステーキサンドイッチショップを見つけて、社内で共有したら、結構多くの同僚が行っているらしいことが判明した。\n美味しい店があっても人がこないと意味がないし、私の財布と胃袋は有限な上に、私の好みはあるので、色々な人に楽しんでもらいたい。 よい共有を行えたと思う。\n今日の勉強 rust TRPL\n pp. 65-68 ヒープデータへのポインタを含む変数のコピーでは、確保されたメモリをコピーする代わりに、コピー元のスタック上のコピー元のを有効ではないとする、つまり、無効化された参照とする。  Copy Traitを実装していないからダメとCompileでエラーが起きる。 shallow copyでない  ヒープデータのコピーなし、 ptr, len, capacityの三つはコピーする しかし、最初の変数を無効化するわけではない   自動的にデータのdeep copyは行われない  自動で行わないから実行コストが低い ヒープデータまで含めたコピーをしたい場合は、メソッドcloneを使う。   moveは、ptr, len, capacityをコピーして、前の参照を無効化する。   通常のコピー  スタック上にすっぽりおさまるようなもの その場合、shallow copyとdeep copyの違いがなく、cloneしても変わらない   Copy Trait  スタック上に保持される方に対して配置される注釈 代入後も古い変数が使用可能  何らかの形態のリソースだったりするものや、メモリ確保が必要なものはCopyではない   単純なスカラー値の集合はなんでもCopy   Drop Trait  これを実装している場合、Copy Traitによる注釈をさせてくれない。   "},{"ref":"https://2222-42.github.io/2020/11/04/20201104log/","title":"20201104log","section":"post","date":"2020.11.04","body":"昨日の予想通り体調が崩れた。\ndiary 昨日、夜まで仕事して、お酒も飲んでしまったので、日課が崩れて、今日の体調も崩れた。\nvacant 虚無な一日を送ってしまった。\n昨晩、薬を飲み忘れ、朝も薬を飲み忘れて、何もできなかった。\nご飯食べて寝るという生活をまた送ってしまった。\n休息は日常生活において重要な役割をはたしているが、それでもなお、虚無な一日を送ることはつらさがある。\necs 朝起きたら、無限再起動ではなく、無限タスク起動が起きていたことが判明した。\n次回の出社で修正する。\ndream 夢の記録\n 部屋の隅で蜘蛛が巣を張っている。 黒と紅。コントラストがキレイ。 蜘蛛がたまごを抱えている。 親の腹を子供たちが食す。  今日の勉強 rust TRPL\n pp. 65-68 文字列リテラルが不変であるから、中身がコンパイル時にわかっているから、バイナリに直接ハードコードされ、高速で効率的になる。 サイズが不明・可変なら、テキスト片用に一塊のメモリをバイナリに確保するのは不可能 String型は、コンパイル時に不明な、メモリをヒープに確保して内容を保持する  メモリは実行時にOSに要求する(String::from) String型を使用し終わったら、OSに個のメモリを返す方法が必要  GCがある言語なら、使用していないメモリを自動で解放 GCがない言語では、明示的に返還するコードを呼び出すのはプログラマの仕事  これの難しいところ:  返還忘れで、メモリの無駄な使用 返還が早くて、無効な変数を生成 返還を二回して、バグを生み出す     Rustが歩む道は、所有権  メモリを所有している変数がスコープを抜けたら(ここが自然な地点)、メモリを自動的に返還する  スコープを抜けたところで、drop関数という特別な関数が呼ばれる   ヒープ上に確保されたデータを複数の変数に使用されるような、もっと複雑な場面でコードの振る舞いは予期しないものになる可能性がある       複数の変数が同じデータに対して、異なる手段で、相互作用する  不変な場合、整数などの既知の固定サイズの単純な値の場合は問題にならない  スタック上に保持されているので、変数のコピーを作成することは、スタックのデータをコピーしている。   String::fromで生成されたものは3つの部品で構成されており、それはスタック上に保持されている。  ptr: 文字列の中身を保持するメモリへのポインタ  その中身はヒープ上に保持されえている。   len: 現在使用しているメモリ量をバイトで表す「長さ」 capacity: OSから受け取った全メモリ量をバイトで表す「許容量」   String型の変数をコピーすることは、スタック上のデータのコピーをしており、ヒープ上のデータをコピーしない 問題点  変数がスコープを抜けると、Rustは自動的に、その変数が使っているヒープメモリを開放する スタック上のデータをコピーした変数、両方は、同じヒープメモリを見ている。 両方の変数がスコープを抜けると、2重解放が発生するのでは？  2重解放の問題は、memory coruptionを産み、脆弱性を産む可能性がある (moveの話につながっていく)       "},{"ref":"https://2222-42.github.io/2020/11/03/20201103log/","title":"20201103log","section":"post","date":"2020.11.03","body":"久しぶりに3時間ほど残業した。\ndiary 久しぶりに3時間ほど残業した。 私のミスを私が修正するためのものなので苦痛ではないが、明日の体調が気になる。\nalcohol and bar BARでお酒を飲む\n ビール(496) ハーパー(12年)  溶液臭さのあるバーボン お腹にくる感じでよい    飲み屋を支える人というのはどういう人かわからないが、過去に100本以上ボトルキープした人もいるらしい。\ncommunication お酒を飲みに行って人と会うことは好きだし、チームをよくするために人と話すのも好きである。 しかし、人を会うことや人と話すことを主目的にする場合はより苦手であるし、他に主目的があるからといっても、苦手なのは苦手である。\n苦手であることについて繰り返し述べているが、人と交流するのが苦手と述べる際に、具体的にどういうところで苦手さを感じているか。 私は、人とのコミュニケーションを、まるで映像のように思い出してしまう。 そして、人とのコミュニケーションにおける自分のコミットメントを重く捉えてしまいがちである。 これら忘れることができない、そして責務を重く捉えてしまっているところから、苦手さを覚えてしまう。\n仕事においては仕事の範囲で捉えるようにしたい。\nHanlon\u0026rsquo;s Razor 人とのコミュニケーションでさんざん悩んできている人間なので、他人の見方に関して、多少なりお悩み解決的なことはできる。 例えば、他人をネガティブに見てしまうことで悩んでしまう人がいる。\nまず第一に、ネガティブに見てしまうこと自体は悪くない。 しかし、ネガティブに見すぎてしまうことは、相手への尊敬の念がないことの表れになり、コミュニケーションがうまく回らなくなる可能性がある。 つまり、ネガティブに見たとしても、別の見方を一度はした方がよりよくなる確率が高まる。\nどう別の見方をするのか、ということを考えるためには、同じ事象であっても状況が異なる場合において、よく人をネガティブに捉える人でも、必ずしも否定的に他人を見るとは限らない場合があることを考えよう。 例えば、路上喫煙をしている人を見たとしよう。この時、その人を見て、以下のように異なる判断をしないだろうか。\n 路上喫煙している日本人を見て、この人は悪い人と思う 路上喫煙している外国人観光客を見て、この人は日本の法律や条例や文化を知らないんだ、と判断する  こういった判断の違いはしばしば発生していると思う。これは差別とかではない。 その人の行為の善悪は置くにしても、その人の行為の理由を推測することによって、その人の行為に対する評価が異なることがあることが重要である。\n上記の事象と同じことを、普段の判断にも転用してみたら、他人の上げ足をとるようなことはしなくなり、楽になり、そしてコミュニケーションが楽になるのではないだろうか。 ハンロンの剃刀と一緒で、無知で済む話は悪意に持ち込まないようにしよう。\nファーストインプレッションでの認識の操作は、文化や知識という、その人の状態に対する判断をするという、事実ではなく文化や環境から判断をする、ということによって達成できる。\n今日の勉強 ecs タスク定義を間違えて、ECSの無限再起動を犯してしまった。\nなんとか修正。\nrust TRPL\n  pp. 61-65\n  プログラムは、実行中に計算機のメモリの使用方法を管理する必要がある\n GC 明示的な確保と解放 コンパイラがコンパイル時にチェックする一定の規則とともに、所有権システムお通じて管理  Rustは第三の道を歩む より自然に安全かつ効率的なコードを構築できる      スタックとヒープ\n この違いで言語の振舞い方や特定の決断を下す理由などに影響以上のものを与える    スタック\n データを追加する(push to)のも取り除く(pop from)のも、常に一番上 last in, first out  スタックにpushするのはメモリ確保とは考えられない      ヒープ\n コンパイル時にサイズが不明なデータや、サイズが可変なデータの場合にヒープに格納する データを置くとき、つまりヒープに領域を確保する(allocate on the heap)ときにやること:  あるサイズのスペースを求める ヒープ上に十分な大きさの空き領域を見つけ そこを使用中にし、 ポインタを返す  (実データを取得するとき、ポインタを追いかける)        現代のプロセッサはメモリをあちこち行き来しなければより早くなる\n  コードが関数を呼ぶと\n 関数に渡された値がスタックに載る 関数のローカル変数がスタックに載る  関数の実行が終了したら、これらはスタックから取り除かれる      所有権が解決する問題\n どの部分のコードがどのヒープ上のデータを使用しているかの把握 ヒープ上の重複しているデータを最小化 メモリ不足にならないようにヒープ上の未使用データを掃除    所有権を理解したら、ヒープとスタックに関して、頻繁に考える必要はなくなる\n  所有権の存在理由: ヒープデータを管理すること\n  所有権規則:\n Rustの各値は、所有者と呼ばれる変数と対応 所有者はいつも1つ 所有者がスコープから外れたら値は破棄される    変数スコープ\n 変数の有効範囲  変数が宣言された地点から、 現在のスコープの終わりまで  スコープに入ると有効になり抜けると有効でなくなる        String型\n 所有権の規則の具体化のために、より複雑な、ヒープに確保されるようんま、データ型を見る 文字列リテラルは不変 全ての文字列値が判明しているわけでは必ずしもない よって、ヒープにメモリを確保し、コンパイル時にサイズが不明なテキストも保持するように、つまり可変にしたい  それがString型   文字列リテラルとString型とでは、メモリを扱う方法に違いがある   "},{"ref":"https://2222-42.github.io/2020/11/02/20201102log/","title":"20201102log","section":"post","date":"2020.11.02","body":"主戦場を探さねばならない。\ndiary how to be mature なぜこの世に生を受けたか。それはこの世を罪から救うという計画に参画するためである。\nでは、最もこの世を罪から救うことができる場所・役割はどこか。 そして、神の目を通して、キリストに繋がっている自分を見つめ、自分のなりたい像のクリアなビジョンは何か。 私はそれらを知らない。\n今私は自分のなりたい像のクリアなビジョンを抱けていない。そしてこの世を罪から救うための主戦場を見つけられていない。 一方で、自分は仕事でやるべきことがあり、必要とされていることがある。 しかし、隣人に貢献をすることの前に主を愛するのが第一である。 主を愛し、そして、運命の場所に私は至らねばならない。その運命の場所は主により定められていることである。 今私が必要とされていることはあれど、それが運命の場所から遠ざかることであるならば、それはやめるべきである。\nしかし、運命の場所をしるためには、自分のなりたい像のクリアなビジョンを抱き、何をするべきかを計算しなければならない。 そのためにも、なりたい像のクリアなビジョンの獲得、運命の場所をしること、隣人に貢献すること、主戦場を探索すること、と相互反復にやっていかねばならない。\n「大人」になる、というよりかは、キリスト者として成熟するためには、自分のなりたい・なるべき人物像のクリアなビジョンを獲得しなければならない。 (これらは繰り返し述べているが、繰り返し述べて、忘れてはならない)\nmature as a christian and as a teammate teamのところで語っていることは、それは、キリスト者としての生活も関わっているからである。 キリスト者として日々重要視している7か条がある。\n 喜び 祈り 感謝し 霊の火を消さず 預言を軽んじず 全てを吟味し良いものを大事にし あらゆる悪いものから遠ざかる  上記のキリスト者としての聖なる生活、穢れのない心を持つこと、これはHRTの原則と重なっているところが多い。 キリスト者として生活し、また、よきチームメイトとして振舞い、そして、運命の場所に至らねばならない。\n最近チームメイトとして課題としていることは、チームの外部とのコミュニケーションをどうにかすることや、時刻の変化に伴うチームのやり取りをどうするか(時間的に将来のチームと今のチーム、また、過去のチームと今のチームとのやり取り、というのはどうしても発生する)、ということである。 これは面白い挑戦であるだろう。 (私が今行っている仕事を他の人にお願いするという水平スケールをやる必要になるのでその点もよいことであろう) (建設業と一緒で、エンジニアリングにおいても職人が一番偉いのであり、外部とのインターフェースの役割を果たすマネジメントとかはそれほど価値を見いだすことが今の私には見いだせない)\nこれ、ほんとうに、自分のなりたい像なのか、運命の場所に近づくことであろうか。疑問を抱いている。 (やった方がいいことであり、これをやっておかないといずれ破滅に至るであろう。)\nsnus SNUSを愛用している。 SNUSというのは、噛み煙草とよく間違えられるが、唇と歯茎の間に配置し、そこからニコチンを摂取するものである。 無煙たばこと分類されるものであり、私は勤務時間中にもこれを口に放り込んで、おかげでニコチンをずっと摂取でき、タバコ休憩をすることなく業務に集中できる。 SNUSのニコチン量はかなり幅があり、私が愛用しているのはsiberiaと呼ばれるシリーズのものである。\nさて、昨日のシガー講習会で、愛用しているそのsiberiaの赤が日本のたばこ店でも取り扱いが始まったことをしった。 どうも日本においてもそこそこキツイSNUSの需要が増えているようだ。\nしかしながら、1缶1100円と、現地価格の倍以上であることがわかった。 さらに、海外は日本とは異なり、まとめ買いやシーズンでの割引を許されているので、結果個人輸入しても、送料や関税を払ってもどうやっても安い。 SNUSにおいて何より良いことは、値段に対してのニコチン量のコスパがよいことであり、日本価格の1100円だとコスパがほとんど一緒になってしまう。 というわけで、今後も引き続き個人輸入する。\nmental メンクリに行った。記録を録っているので、問題の列挙と、要望を的確に伝えられた。\nスルピリドを再度もらった。 スルピリドは以前食欲が湧かないときにもらったが、先日の抑うつ状態の解決に使えたので、欲しいと伝えた。\nこれで服用している薬としては、デパスを睡眠前に2錠、朝食と夕食後にスルピリドを1錠、となった。\nそういえば、昨日のシガー講習会の中で参加者の方が語っていたことに、 肉、甘味、蒸留酒、シガー、という一連の流れは、脳幹を通って脳に快楽物質を生成・放出するものを伝え、そして、胃腸を整えてくれるということがあった。\n今日は、それを踏まえて、カレー、きのこの山、煙草、と楽しんでみた(アルコールは摂取しなかった)。\nキリスト者としてチームメイトとして活動するためにも、抑うつ状態と不眠は避けねばならない。\n今日の勉強 rust TRPL\n pp. 56-60 フロー制御のループ  本体内のコード尾最後まで実行し、直後にまた最初から実行を開始する   loop  ずっと回り続ける Ctrl + cかbreakキーワードかで、プログラムの実行を終了できる   while  条件付きループ  loop, if, breakで作れるが、while使う方がいい   条件が真の間ループが走り、条件が偽になったとき、真で亡くなった時、breakを呼び出す   for  コレクションの覗き見 whileやloopでも実装できるが、これらではコードの安全性が落ちる  添え字の長さの間違いによる、パニックの発生や見落としの発生 毎回教会地チェックを行うようなコードになるので、実行が遅くなる   forループだと安全性を損なわない  配列の要素数を変えてもパニックが起きない   Range型を使っている  疑問: サンプルコードで利用しているのはIter型を返しているようだが、Range型とIter型との関連は？      課題とされていたもののうち、 フィボナッチ関数の実装と\u0026quot;The twelve days of christmas\u0026quot;の歌詞の生成の実装をやる。\nteam  ソフトウェアを書く理由は、他人が幸せにすること。 だから、  他人が幸せにならなければ、 feedback loopの方法を身につけなければ、 ソフトウェアは死ぬ。    User Engagement\n ユーザーの気づき(マーケティング; どのように見られているかに気を配る) ユーザーの体験(ユーザビリティ; ユーザーが離れるのを避ける) ユーザーとのやり取り(顧客サービス; 長期的な関係構築が、ソフトウェアの進化とユーザーの定着に影響を与える)    マーケティングは、エンジニアリング文化で重要視されている事実ベースと相性が悪いが無視できないが、うまくやる方法がある\n 感情的な知覚に配慮する  認知したもの勝ち   第一印象に注目する 小さく約束し、大きく届ける(見積もりを大きくしたり、予告をしなかったり) 業界のアナリストとうまく付き合う    ユーザーに集中すれば、他のことは全てついてくる\n これが、プロジェクトの成否にも関わる 観客を選ぶ  最重要なのは、ユーザーの技術的能力を考える   入り口のハードルを下げる  最初の体験が超重要。 アカウント作成を強要しなかったり、スピードを優先したり、と。   ユーザーではなく、利用を計測する 速度重要  速度は機能ですらある。(非機能要件とよく言われるが、Googleの人は機能要件と捉えているようだ) レスポンスが速ければ、待ち時間が短くなり、何度でも使うようになる  無意識により多く使うようになる   利用数の停滞の原因は、多くは速度・スループットにある。   多くのユーザーの共通の問題を解決する ユーザーにとって使いやすいソフトウェアを作るためにはなまけないこと 複雑さを隠す  複雑さを隠し、簡単なことをしているように感じられるようにする、つまり抽象化する(インターフェイスの柔軟さ)  しかし、ユーザーを不自由にしてはいけない  抽象化が漏れる場合のバイパスを用意すること   ユーザーの信頼を得ることが最も大切なリソースである  これのために、インターフェイスの回避を用意すること          ユーザーとの関係の管理\n ユーザーは話や自分の意見を聞いてもらいたく、関係を築きたいと思っている  話や意見の存在や内容を認知することが重要 ユーザーはHRTのある会社なら好きになる   ユーザーと開発者との間に壁を作ってはならない  ユーザーの増加は技術能力の平均レベルの低下を招き ユーザーの失望を増やし 苦情の増加を招く けれど、その苦情を開発者に届けさせないことはダメなことだ。      見下さない\n ユーザーの質問や意見はユーザーの知能とは関係ない ユーザーに敬意を払おう    我慢する\n ユーザーは問題をうまく表現できない  語彙の統一がされていないという問題がある      信頼と喜びを作ろう\n 信頼  おおよそ感情的に正の状態が積み重なった結果のもの すぐ吹き飛ぶ 最も大切なリソース  残高に気を配ろう 長期的なイメージを持とう     喜び  幸せな気分にさせる驚き  ユーザーを大切にしていることを伝える        HRT、これの欠乏が問題を引き起こす\nHRTの原理を、『Team Geek』では、以下のように広げていった。\n 自分 チーム チームをリードする方法 チームの外部とのやり取り ユーザーとのやり取り  この手法は、エンジニアリングのみならず、あらゆるコミュニティが対象となる。\n要約は以上。\nメモを録っていなかった前半の章を合わせて、会社で発表するための資料を後日作ろうと思う。\nisabelle Concrete Semantics\n pp. 151-152 com x state =\u0026gt; state optionという案  semicolon ruleで問題となる  option型とそうでない方とを組み合わせた規則で、かつ、Noneの場合とそうでない場合との2通り作ることになる   一度に全てをやりたい   com x satate option =\u0026gt; state option  入力も出力もoption型にしよう。 produce error propagate error   求めるstatement: well-initialized programs cannnot go wrong  [| D (dom s) c A', (c, Some s) =\u0026gt; s' |] =\u0026gt; s' /= None   "},{"ref":"https://2222-42.github.io/2020/11/01/20201101log/","title":"20201101log","section":"post","date":"2020.11.01","body":"葉巻を楽しんだ。\ndiary cigar 今日は、五反田にあるシェリーミュージアムにて、葉巻の講習会に参加してきた。\nシェリーミュージアムに行くのは初めてで、どういう周辺を10分ほどうろうろしてしまった。 五反田には時々行っているが、それほど夜の街を知らない。\n講習会では、葉巻は4本いただき、その場では2本楽しんだ。 講習会は初めての試みらしく、形式とかは特に定まっていなかった。 講師の方(もともと知り合いの方なのだが)がすごく楽しそうに語られていたのが、何よりもよかった。 また、もともと葉巻の細かいところや深いことについては知らなかったので、よい勉強になった。(初心者向けだったり、中級者向けだったり、上級者向けだったり、という話が混在していた。)\nカットがへたくそな人間であるが、今回でやっとある程度つかめたかもしれない。\nシェリーはショット計算で大体10くらい。あと、スコッチとラムをそれぞれハーフショット。\nシェリーは辛めから甘目まで色々あり、楽しめた。 今回はシェリーの講習会ではないので、詳しくは聞くことはなく、葉巻の前半、中盤、終盤とのペアリングを調べながら楽しんだ。\n他にも色々と面白い話があった。アロマとブーケの違いとか。 特に、コーヒー、樽酒、煙草、これらの様々な化学的類似点や文化的背景とかが聞けたのは面白かった。\n今の日本ではほとんどない純喫茶の発生経緯とか、最初の純喫茶と、日本の純喫茶の共通点とか、が特に覚えている。 純喫茶が近くにないだろうかと疑問を持った。 (調べたら、新宿の珈琲貴族エジンバラも純喫茶に分類されるらしく、実はすでに訪れていたのであった)\nゆったりとニコチンとアルコールを楽しみながら、他人の話に傾聴する。これはとても有意義な時間の過ごし方であった。\ntired 今日は昨日の疲れが残っているようで、朝寝坊して、朝ごはんを食べて寝て、昼ご飯を食べてさらに寝て、と睡眠を繰り返していた。\n夜の葉巻講習会には無事に参加できたのでよかった。\n今日の勉強 rust TRPL\n pp. 49-56 関数の戻り値  戻り値に名前を付けない 戻り値に型をつける  関数の引数の後に、「-\u0026gt; + 型」で付けられる。   関数の戻り値は  関数本体のブロックの最後の式の値に一致する  式ではなく文にしてしまうと、空のタプル()になる。  疑問: Rustにおいて、SMLのようなunit型はあるのだろうか？     もしくは、returnキーワードで早期リターンした値に一致する。     コメント  二連スラッシュで始まり、行の最後まで続く コンパイラはコメントを無視する コメントは、色々な種類があり、それに関する議論は14章で行う   フロー制御のif式  「if + 条件式 + { + 実行したいコード + }」という構造になっている。  else式をオプショナルに追加することができる 条件式はbool型でないとコンパイルエラーが起きる  論理値以外の値が自動で論理値に変換されることはない。     else if式で、複数の条件を持たせることができる  条件式が多いと可読性が落ちるのでmatchが有用になる(cf: chap. 6) if 式が順に吟味され、最初に真になった本体が実行され、それのみが実行され、それ以降のif式はチェックすらされない。   let文内でif式を使う。  if式は式なので、let文の右辺に持ってくることができる。  e.g., let x = if cond {a} else {b} ifアームとelseアームとで型が一致していることが要求される。  これは、条件式の値に依存しない。   なぜなら、変数は単独の型でなければならない 単独の型でなければならない理由は、複数の方を追いかけて、その変数が使われている全箇所でチェックすることは、コンパイラをより複雑にし、コードに対して結果的に保証が少なくなるから。       "},{"ref":"https://2222-42.github.io/2020/10/31/20201031log/","title":"20201031log","section":"post","date":"2020.10.31","body":"どうやって大人になるのか。\ndiary how to be mature 一年ほど前、自分より一回り上の方から、大人になろうと叱責されたことがある。\n大人になるというのがどういうことかわからなかった(今でも正直わかっていない)。折に触れてそれを思い出し、どうすればいいだろうかと悩んできた。 そこからだいぶ時間が経ち、また色々と経験し、そして人の意見を聞いてきて、大人になるということについて一つ以下のようにまとめることを試みる。\n仮説: 若いからという言い訳が効かなくなることで困ることを避けれるようにすることが大人になること\n若いころは、なんでもできるんだと尊大であったり、下に観られていたり、約束を破ったり、学習期間としてそれが認められていた。 しかし、年をとるだけで、それが認められなくなる。 若いころに許されていたことをやると許されなくなる、そしてそれをやらない・避けるようにすることが大人になるということであろう。\nつまり、大人になるというのは、謙虚な人と認識されること、尊敬の念を抱かれること、信頼されること、とHRTの原則に従っている。\nこれらを実現するために、色々なやるべきことがあるだろう。例えば、\n 先日記録したような人に話すときや人から聞くときの立ち振る舞いや伝え方を身につけること、 相手の困っていることを適切に分析し、解決し、相手に貢献をすること、 約束したことは実現し、できないことはできないと伝えること。  上記のことですら、私はまだ完全には身につけられていないし、 大人になるということが本当にどういうことなのかわかっていない。 だから、まだ私は大人になれていないだろう。\n大人になるということに安心感を覚えたり、大人にならざるを得ない環境になりつつあることを予感しつつある私は、大人にならなければならない。\n大人の定義の補足 上記の仮説は、子供ではないという否定からスタートして大人を探すものである。\n大人が満たす性質からそれを探していくことをやらねばならない。 そして、そういったボトムアップの定義とトップダウンの定義の両方が一致することが期待される定義である。\nそして、私が探している運命の場所に至るためには、この定義を見つけねばならない、そして、自分がなるべき人間に関する像に関するクリアなビジョンを抱けるようになり、そして最後に運命の場所に至るのである。\nbuild a desk 水曜日に届いたデスクで、足りていなかった部品のビームが今日届いた。\n天板がとても重くて組み立てるので非常に苦労した。 疲れのあまり、椅子に座りながら眠ってしまった。\n重さのある天板であるということはかなりの広さがあるということであり、かつ、十分な頑丈さがあるということである。\n 広さという観点から語れば、キーボード、マウス、メモ帳などを置けば、それでいっぱいになっていた環境から、それらを余裕をもった間隔で置いてもまだスペースは十分である。 頑丈さという観点から言えば、これまで使っていたIKEAのものだと、ディスプレイアームでクランプで硬く絞りすぎるとへこむということがあったが、そんな心配はしなくて済む。  必要な物品に対して、優先順位を立てて、いちいちものを動かす必要がなくなり、必要な物品をそのまま机におけるのは生活の質の向上すらも感じてしまう。\ntime 今日は土曜日で安息の日としているので、時間に縛られないようにした。 しかし、時間に従った結果に伴う喜びを味わえないのは本当に残念である。\n今日の勉強 rust TRPL\n pp. 45-49 関数  命名規則はスネークケースが慣例   引数  関数シグネチャの一部になる特別な変数  複数を持たせることができる。持たせるときは、,で区切る。   仮引数(parameter)  関数定義の変数 型宣言が必須   実引数(argument)  関数の呼び出しの時に渡す実際の値     関数の構成  複数の文と最後に文か式を置くことで構成されている   文  何らかの動作をして、値を返さない  よって、例えばlet文を他の変数に代入できない   文は終端にセミコロンを含む   式  結果値に評価される 式は文の一部になりうる 式は終端にセミコロンを含まない  終端にセミコロンを含めると文として解釈される  文として評価されると型が()となる     関数呼び出し、マクロ呼び出し、ブロック、いずれも式   "},{"ref":"https://2222-42.github.io/2020/10/30/20201030log/","title":"20201030log","section":"post","date":"2020.10.30","body":"人にものを伝える時は 3 つのissue と 1 つのお願いという形式が楽。\ndiary how to assert 人にお願いするときは、3つの課題と1つのお願いという形式が楽だな、とよく感じる。\nこちらが意図的にコンパクトにしていると、相手がどう読むかわかりやすいし、相手はすぐ読める。(結局、伝えられることが一番だから)\n例えば、以下のような内容があるだろう。\n 小腹が空いていると集中力が落ちます 軽食を買いに外に出るのは時間の無駄です 会社に軽食があると共通の話題を作りやすくなります  お願い:会社におやつを置いてください。\nCommunication 相手への尊敬の念や、共感や労りの気持ちを持つのは非常に難しいが、それっぽいふるまいをするのは簡単である。 (そして、共感をしすぎて共依存するのもよくないから、先んじて境界線を引いておく)\nたとえ、相手の意見やお願いの筋が通っていなくても、一旦それを受け入れ共感を示して、労りとしてやってみて、提示して、やっぱり違うね、という共通見解を得てから、もとの意見やお願いを訂正する、というのが角が立ちにくくなるだろう。 これはとてもコストが高く、無駄が多い。 が、人間は愚かで、伝えられた言葉や伝え方に無駄や冗長さがないと、自分が馬鹿にされた気分になるらしい。\nなんでこれでうまくいくのかはわからないが、うまくいくんだったらその方法を採用する。\nWi-Fi 契約状態を確認して、CAF番号を確認して、終端装置を確認して、サポートされているルーターを確認して、設定し、と一連の作業をしてやっと設定できた。\n全体のフローを先に知っておかないと無駄に時間を浪費してしまう。(およそ6時間ほど時間を使ったことになるが、知っていたら2時間もかからなかっただろう)\n配線もそうだが、専門の業者様が如何に素晴らしいサービスを提供しているか。尊敬を覚える。\n今日の勉強 rust TRPL\n  pp. 36-44\n  shadowing と mut との違い\n シャドウイングは新しい変数を作っているので、値の型を変えつつ、同じ変数名をつかえる 可変変数の場合は、同じ変数なので、型を変えることはできない    型注釈が必要な場合がある\n 型推論をして、複数の型が推論される場合がある Rustは静的型付け言語であり、コンパイル時にすべての型が判明している必要がある だから、型注釈で型を明示する必要がある    スカラー型\n スカラーは単独の値のこと 整数型  整数型の基準型はi32   浮動小数点型  浮動小数点型の基準型はf64   論理値型 文字型(文字列型ではない)  charはunicodeのスカラー値 補足: 文字はUNICODEの概念ではない。      複合型\n 複数の値を1つの型にまとめることができる。 タプル型: 複数の型の値を1つの複合型に。位置ごとに型が定められている。  タプル型の値へのアクセス方法は、パターンマッチングによる分配か、.0や.1などピリオドと添え字による方法。   配列型: 全要素は同じ型。固定長。  配列型の値へのアクセス方法は、[0]や[1]などのかっこで添え字を囲む。 配列型は固定長であり、サイズの伸縮はできない。ベクタ型という配列型とよく似たコレクション型はサイズの伸縮ができる。  固定長の配列型では、長さ以上の添え字を使った場合、無効なアクセスとして、処理を継続させず終了させる。 疑問: テキストでは、実行時エラーが発生させるとあるが、実際にやってみたところコンパイル時のエラーが発生した。       "},{"ref":"https://2222-42.github.io/2020/10/29/20201029log/","title":"20201029log","section":"post","date":"2020.10.29","body":"地獄への道は善意で舗装されている。善意で二回オフィスのWi-Fiの設定をしたら今回も依頼されて、地獄だ。\ndiary Wi-Fi Wi-Fiの設定はまじでわからない。これまでと契約先が違うプロバイダを一時的に使うことになったが、本当に大変だ。なんもわからない。明日もそれの対応がある。 (配線や環境構築はその専門の人にお願いするのが絶対コストがやすい)\n何よりもつらいのは、旧オフィスと新オフィスを往復する頻度が多く、かなり多く歩くことになっていることである。\nおかげで近くに面白いバーベキューサンドイッチ屋を見つけられた。\nTeam チームとその外部とのインターフェースについて悩む。\nやりとりを手軽に、かつ、相互の尊敬や信頼を伴ったようなインターフェースは難しい。\n私は人に意見を伺う時や意見を提示するときは、直接相手のところに伺って、相手の目線より下に自分の目を置く、ということをしている。 これは相手への尊敬の念を示すのに非常に効果的であると思っている。 (ウェブカメラでも同様で相手を見下す形ではなく見上げる形にするのがよいと私は思っている。)\n相手に何かを伝えられる自信のない私にとって、物理的な振舞いというのはある種の保証でもある。\nさて、いざこれを個人ではなくチームや部署レベルで実施しようとなると難しい、特にテキストベースだと難を感じる。 というのも、相手にこちらの文章の意図が伝わり切れない、コミュニケーション不全があるかもしれないからだ。それは個人の言い方や伝え方の問題というよりも、その言い方や伝え方をどうして採用しているのか、というところがある。\nこれは、ネットの問題ではなく、人間の問題であり、人間がコミュニケーションに向いていない、もしくは、人間が言語以外の要素に多く頼ってコミュニケーションをしていることが原因であり、さっさと人間は一つになるべきだと私はしばしば思う。\nしかし、人のコミュニケーション能力や言語以外の要素に頼っていることを排除し、1つになるということは現時点ではできないから、インターフェースをよりよくしないといけない。\n銀の弾丸はないので、手探りでやるしかない。チーム内の文化と外部とのインターフェースは協調をもって確立する必要があるのではなかろうか。 (チーム論について隔週で部内で発表するトライについて提案をしてみた。これで解決するというよりも、これで歩み寄り、これで次の一手や方向性を探り出したい。)\nSound チームメイトからお古のDACとアンプを譲り受ける。\n久しぶりの音響関連製品の購入だ。\nこれの効果を直に感じるのは毎回難しいと感じる。この音を出したい、余計な音を削りたい、という強い意志がないと音響関連はその力能を十分に発揮できない。\n画面上での音量の調整ではなく、物理的なダイヤルでの調整を久しぶりで本当に楽しい。\n今日の勉強 rust TRPL\n pp. 24-36  手書きのメモを文章に起こし直す(手を動かしたほうが楽)\n2章\n 変数(let ...で宣言)  immutableとmutableがある。不変がデフォルト。   参照(\u0026amp; ...で宣言)  可変と不変両方ある。   クレート(外部クレートとバイナリクレートがある)  外部クレートはCargo.tomlに記述して、全ての依存をダウンロードさせられ、また、Cargo.lockでビルドされるものを再現できる。 外部クレートを.rsで仕様するために宣言するのにはuse ...を使う  トレイトに定義されているメソッドを呼び出せる     関連関数(::)  型に対して実装された関数  疑問: 関連関数とトレイトに実装されているメソッドとの違いは何か。 予測: トレイトはinterface的なもの？     match  armがある   Result型  OK(v)とErr(e)のenum Errの場合.expect()でクラッシュする  クラッシュを避けたいならmatchを使おう     シャドウイング(覆い隠し, shadowing)  新しい値で変数の値を覆い隠す 値を別の方に変換したい場合などでよく使われる   loop, break  3章\n コンパイルエラー  潜在しているエラーを見つけ出す手助けをし、 プログラムにしてほしいことが安全に行えていないことを示している   値が不変と宣言すると、コンパイラがそれの担保をする  不変であることのメリットは、変化を追いかけなくてよく、コードを通して正しいことを確認するのが簡単になる 可変や不変と宣言したら、将来の読者に変数の意図を伝えられる 可変である方がよい場合というのは、大きなデータ構造の場合などが挙げられる   変数と定数  定数は不変定数ではない 定数の命名規則は大文字とアンダースコアのペア(e.g., ABC_XYZ) 値の型は必ず注釈する 任意のスコープで使用できる、globalでもlocalでも 定数は定数式にしかセットできない  呼び出し結果や実行時に評価される値にはセットできない     "},{"ref":"https://2222-42.github.io/2020/10/28/20201028log/","title":"20201028log","section":"post","date":"2020.10.28","body":"my new gear\u0026hellip;\ndiary desk 注文してたOKAMURAの机がオフィスバスターズから届いたけれど、部品が足りなくて、部屋の置物と化した。\nかなり重いデスクなので、汗をかきながら設置しようとして、これだから絶望感がひどかった。\nこれについては、お店側に連絡して対応をしてもらい、近いうちに足りない部品が届くことになった。\nwtf 会社でなぜか社内サーバーを導入する流れになっているらしいが、開発部門は全員反対し、 そして、反対している開発部にその助言や設定をお願いするという珍事件が起きている。\nこれについては、さっさと諦めてもらうために、コストやリスクを説明して、冷静になってもらおうと思う。 (もちろん、冷静な判断でその選択を取ることはありうる、という前提で話さなければならない。) (20201017logに記載のある「無能(無知)で十分説明されることに悪意を見出すなというハンロンの剃刀」は思い出して置かねばならない。)\nこういった問題の認識と、要件の確認とは、開発が得意とすることであるから、やっていこう。 あと、人間関係を壊さないようにうまく立ち回ろうと思う。\n今日の勉強 rust TRPL\n pp. 11-24  guessing_numberをやっていく。 SMLの勉強をやっていたおかげで、前回の時よりも何をやっているかがわかりやすくなったかも？  (もしかしてちゃんと印刷したからかもしれない)     "},{"ref":"https://2222-42.github.io/2020/10/27/20201027log/","title":"20201027log","section":"post","date":"2020.10.27","body":"薬は偉大で、安定して活動できる。\ndiary 薬の効果かどうかわからないが、食欲も戻り、活動意欲も戻り、順調に活動できた。\n明日はブーメランデスクが届くのでそれが楽しみだ。\nwork 今日の仕事はオフィスの引っ越しに伴い、回線の設定をやっていた。使えるルーターがこんなに制限されているサービスがあるとは思わなかった。 おかげで、久しぶりに一万歩歩いた。\n設計について色々相談することができた。 これまでは、今やらないと死ぬから自分で実装する、という状況から、破滅を避けるために長期的にチームでどうやっていくか、という方向にシフトできるようになった。 これもまた、いわゆる「防御的」な仕事であるが、よい経験になると思うので非常に良い。 特に、これまで考えていなかった思考や思想に触れられるので、とても刺激的である。(独りでの仕事だとどうしても至らない事柄である。)\n面談 趣味はカジュアル面談です。\n今回相談したところでは、相手の文化や制度を聞きつつ、仕事内容を聞いて、そのうえで、自分の視点からより突っ込んだ質問をするということができるようになってきた。\nまぁ、私が思いつくような疑問点というのはおおよそ採用をやっている人やマネージメントをやっている人は考えていることなので、現在の状態と今後の方針を教えてくれるので、カジュアル面談をやるような会社さんはすごく計画的な採用をしているんだな、と実感した。 特に、事業およびプロダクト・プロジェクトの過去の経験から、事業の向上に繋がる課題の認識、どう解決していきたいか、というところまで見れる。 明確である分、聞きに行く人間としてはすごくよい体験を得られるし、相手にも私の興味や関心を伝えられ、自分だったらこういうことができるということが提案できる。\n私が毎回質問するのは、仕事をどう評価するか、事業として、プロジェクト・プロダクトとして、チームとして、が挙げられる。 それがしっかりしていないとチームもメンバーもやりがいが減るからであり、文化が衰退していくと感じるからである。\n現職から離れる予定はそうそうないが、自分のキャリアを考える上では非常によい参考になる。\n今日の勉強 rust TRPL\n pp. i-10  前の版で読んだのでそのまんまやっていく。    画面上だとどうしても読めないので、pdf版を印刷して読んでいる。\n"},{"ref":"https://2222-42.github.io/2020/10/26/20201026log/","title":"20201 26log","section":"post","date":"2020.10.26","body":"虚無から脱出する方法を見つけられた。薬だ。\ndiary how to handle depression 虚無から抜けるためにやる気で解決するのはやはり駄目だった。\nノートを見返していたら、数ヶ月前も同じようなことが起きていた。その際は、ちょうどメンクリにいって、スルピリドをもらって、すぐ解決したことを記録していた。\nすぐ解決できたので薬がまだ残っていたので、飲みだした。布団から立ち上がれるようになった。 そして、ずっと残っていた洗濯物を畳み、掃除をし、一個一個生産的なことをするようにした。\n前回も同じように、少し飲んで、一個ずつ片付けていき、回復したのだった。\n鬱というのは、デフレスパイラルのようなもので、どこかで上昇に切り替えないといけない。 それのきっかけがお薬なのである。\nこれで一応私の先週木曜からの虚無感がやっと抜けられそうだ。 次回のメンクリでは、この件について相談して、再度出してもらおう。\nlog 今日やったことをリストアップするととても良い\n コーヒーを入れる 洗濯物を畳む 風呂掃除をする 便所掃除をする 不要な机を片付ける　→　だいぶ部屋が広くなった 窓を開けて掃除機をかける 詰まっていた排水管にパイプユニッシュを入れる SNUSが国際小包で届く 湿疹にイライラする。  今日の勉強 sml  問18.39  copyの実装を間違えていた箇所が見つかったので、それの修正を終えた。 修正を終えて、なんとかWebshの実装が完了した。    残っているのは、「18.14　プログラミング課題」であるが、これはFuture Work的な側面が強い。 発行から20年経った現状、SMLでのこれ以上の開発はそれほどやりがいを感じられない(やるとしたらSML#だろう)から、 また、Rustの勉強をやりたいと最近感じているからである。\nこれにて、とりあえず『Standard ML 入門』を一旦終えることができた。 いずれこれについて、何か記事をまとめることにしようと思う。\nTeam Geek 『Team Geek』の5章(pp. 121-146)を読む。\n気になったことと自分への振り返りのためのメモ書き。\n 約束を小さくし、届けるものを大きくしよう。  できないものに「No」と言う意味で約束を小さく プロダクトのローンチをするという意味で届けるものを大きく   許可を求めるより寛容を求める 道がないなら道を作る  置き換えるなどをして対処する 誰から聞いた言葉かは忘れたが、「壁にひざまずくのではなく、壁を打ち砕くのではなく、壁をすり抜けよう」という言葉を思い出した。   悪いマネージャーや社内政治家や悪い組織体制の存在に気付き、適切な対処を身に着けよう  幸いそういう悪いものとは遭遇していない だが、いずれ出会うかもしれないし、私がそれになるかもしれないので覚えておこう   チームメンバーとしての価値の向上をしよう  責任範囲を広げる リスクをとる(早い失敗をするため) 大人らしく振る舞う 質問をする マネージャーはエスパーではないことを覚え、積極的に連絡する。   「攻撃的」な仕事と「防御的」な仕事  政治的信頼性の獲得をしやすい攻撃的な仕事、UI改善や新規機能開発 防御的な仕事というのは生産性をあげるためのリファクタリングなどの負の遺産の整理である。 筆者らは、3分の1から2分の1までしかかけないようにしており、それ以上は政治的自殺行為であるから、と述べている。 私は4分の3以上が防御的な仕事なので、もう終わりだ。  なお、ここまで防御的な仕事になったのは、昨年外部と関わった仕事で、内部の攻撃的な仕事に関われなかったことがきっかけなのかもしれない。     運を味方につけるためには、気づくことが重要で、その気付きには、人の仕事を手伝うことが重要  それによって人のつながりが得られ、それは会社から抜けた後でも続く   ポジションを上げよう 強力な友達を見つけよう  管理とは仲良くなろうと思った   行動を要求するメールの書き方  最大3つの問題についての説明の箇条書き 1つだけの行動要請 HRTの原則に基づいたお願いや質問をすること 問題の詳細等については、お願いやメールの締めの後に、追加する。   自分自身の将来をコントロールできる能力を身につける。 "},{"ref":"https://2222-42.github.io/2020/10/25/20201025log/","title":"20201025log","section":"post","date":"2020.10.25","body":"虚無を終わらせたいが、これを終わらせる方法を私は知らない。\nずっとYouTubeで映画のあらすじや考察系の動画を見ていた。\n虚無から抜け出せない。\n脳みそが動かない。記憶が短期的すぎる。\n今日の勉強 sml 『Standard ML 入門』\n pp. 264-265 問18.37  HELP で表示させるエラーメッセージの一部を作成   問18.38  linkやfollowを使った場合に、Parseがうまくできていなかったことに気づいた。 printしまくって、なんとか原因の特定と対処をした。    問18.39のcopyの実行で、うまく実行できていないことがわかった。 次回はそれの修正をしよう。\n"},{"ref":"https://2222-42.github.io/2020/10/24/20201024log/","title":"20201024log","section":"post","date":"2020.10.24","body":"虚無が続く\nゲーセンに行く。\n富士そばを食べる。\n勉強をする気が起きなかった。\n"},{"ref":"https://2222-42.github.io/2020/10/22/20201022log/","title":"20201022log","section":"post","date":"2020.10.22","body":"虚無\n虚無だった。 何も手がつかず、身体を布団から動かすことができなかった。\n本来の予定では、会社の合宿があったのだが、完全に私は寝坊して、二度寝をして、ぶっちをした。\n虚無である。\n今日の勉強 sml 『Standard ML 入門』\n pp. 263-264  topLoopの分岐の写経   "},{"ref":"https://2222-42.github.io/2020/10/21/20201021log/","title":"20201021log","section":"post","date":"2020.10.21","body":"虚無\nチキンのトマト煮を作る\n自分の社会活動のすべてが虚無に思えてしまい、何もできずに時間をすごす\n今日の勉強 sml 『Standard ML 入門』\n 問18.33 問18.34  とりあえず型エラーが起きないものを書く 実際のコピー処理については、18.13節でやってみる   "},{"ref":"https://2222-42.github.io/2020/10/20/20201020log/","title":"log","section":"post","date":"2020.10.20","body":"季節の変わり目と身体の疲れと心労とによって、魂の冷え込みを感じる。\n季節の変わり目での体調の問題を感じる。心と体の連関は深く、体を意識してコントロールし、魂を十分に発揮させねばならない。 また、今日あえて意識的に振る舞ったことは、心の疲れを生む。 これらによって、魂のちからを十分に発揮できなかったような気がする。\n本質的に重要なのは、何をなすかではなく、どいういう人になるかである。\n効果的な証人であるためにはどうするか。 他者が私達の人生の中に何を見出すことを神が望んでおられるか。 それは神のご性格であり、それはイエスが模範を示している。 愛、喜び、平和、寛容、親切、善意、誠実、柔和、節制、これらを禁じる掟はない。 これらを実践することこそが、愛の実践であり、これこそが他者が私の抱いている希望について説明を要求する人にいつでも弁明できるように備えることになる。\n今日は、これらを意識して、振る舞うようにしていた。 できていたであろうか。 しかし、意識してそれをやることは時に疲れを生む。 あくまでも意識してやること、仕事としてやることは、境界線を引いて、思いやりの限度を持たねばならない。\n今日の勉強 sml 『Standard ML 入門』\n pp. 261-262  structure CopyUrlの補助関数以外のところを写経   問18.31  相対パスについての実装を終えた    cdk CDK deployでよくわからんことが起きたから、 cdk synthで、Cloud　Formationを出力させようとしたら、\n Object.fromEntries is not a function\n というエラーが発生した。npm audit fixしても、node_modulesを無限に消して再インストールしても、駄目だった。新しくlocalにrepositoryを立てたら直ったからヨシ！\n結局、CDKでよくわからないところはCloud Formationで調べたら何が足りていないかがすべてわかった。\n"},{"ref":"https://2222-42.github.io/2020/10/19/20201019log/","title":"20201019log","section":"post","date":"2020.10.19","body":"今日は寝坊した。 そして、昨晩より続いていた気分の落ち込みが依然としてひどいことに気づいた。\n今日は寝坊をし、午前6時に起床した。 寝坊をするということは、なんらかの問題があることだ。\n季節の変わり目や、天気が悪い日は、特に気分が落ち込んでしまう。 ドーパミンやアドレナリンが足りないだけであり、私の魂は変わらないままであるはずだ。 そうであるはずなのに、気分は進まない。\nあと、ここ最近の聖書日課であるところのエレミヤ書の内容がすごい暗く、我々に破滅を預言している内容であることも関係しているかもしれない。 霊の火を消さず、預言を軽んじない、というのは今期の私の目標のうちの1つであるから、これに耳を傾けねばならない。\n聖なる生活を送り、穢のない心をもって歩もう。\n覚書 仕事で思ったこと 仕事について、バス係数を高めよう、と思った。\n水平にスケールしなければならない。 そうでなければいつまでも、私はベン・ハダドの谷から、抜け出すことができず、運命の場所にたどり着けない。 さらには、他者に貢献する機会を損なってしまうことに繋がるだろう。\nまた、私が今やっている仕事のバス係数を上げる他にも、同僚がやっている仕事のバス係数を上げよう。 それもまた、他者に仕えることである。 自分の仕事のバス係数を上げることとと、同僚の仕事のバス係数を上げることが一致する課題もあるだろう。それを探して、実施してみるのも良いことである。 (例えば、自分の問題意識を設計にして意見を聞くことは、設計を担当している人の仕事のバス係数を上げ、また私の仕事のバス係数を上げることになるであろう。)\n問いかけの向上 今日は少し、問題解決モードではなく、問いかけに意識を向けるようにした。\n良い試みであると思った。もっとよりよい問いかけを実施しよう。\n神のご計画の一部としての行動と愛とふるまい 運命の場所 運命の場所に至らねばならないという思いをいだき続けている。 そして、今の場所がベン・ハダドの谷ではないかという疑いも抱いている。\nもし今の場所が煉獄であり、そして、運命の場所に至るためには、進んで離れなければならないときが私にはいずれ来るであろう。 いつでも備えていなければならない。夜に新郎新婦が祝いの席に来るかもしれないのであり、そのためには灯火を用意し、寝ていてはならないからである。\n運命の場所に至るために、私は生まれ、そのことは、神のご計画の中にいる。\n灯火は燭台の上に 神のご計画の一部として、愛を持って行動することが含まれている。神は前もって準備してくださった善い業のために、キリスト・イエスにおいて作られたのであるから。\n愛を持って行動することは、先日から述べている通りであるが、この愛を持った行動は、自分の愛だけではなく、私達を通して神の愛を表明することでもある。 効果的な証人にならねばならない。 これが、世の光となる。\n今日の勉強 sml 『Standard ML 入門』\n pp. 261 問18.31  絶対パスについての実装を終えた 相対パスについての実装をしなければならないことに、通勤途中で気づいた。    冒頭で述べたとおり、朝起きれず、それほど時間を取れなかったことを後悔している。\n"},{"ref":"https://2222-42.github.io/2020/10/18/20201018log/","title":"log","section":"post","date":"2020.10.18","body":"PCを買うよりも新しい机を買おうと思い直した。\nPCを新調しようと定期的に思いついてしまうが、いや、結局今のマシンでも十分であるし、その金で机を新しくしたほうがいいと思い直した。 (つよつよPCを作るくらいなら、AWSでremote 開発環境を作った方が安く済む。また、PCの資産としての価値は低いから。)\n現在の机はIKEAのもので、だいぶぼろぼろになっている。また、机の広さも足りなさを感じている。\ndiary 午前中。\nチキンのトマト煮を作った。 間違えてカットトマトではなくホールトマト缶を買っていたことに気づいたが、うまく作れた。\nFEBCで日曜礼拝を聞く。\n午後は頭痛がひどくて、そして虚無が襲い掛かってきた。何にも手がつかなくなった。\n感情をコントロールするためには、体を動かす必要があるが、その気持ちすらわかない場合にどうすればいいのだろうか。\n愛の実現のために 信仰は望んでいる事柄を確信し、見えない事実を確認すること。つまり、神の存在や神の愛を確認できる。\n行いが伴わないなら、信仰はそれだけでは死んだもの。信仰という心から神へ愛を伝えるチャネルを成長させるためには、行い・活動が必要である。信仰が愛を導き、行動がその愛の実現を導く。 御言葉を読み、神が私達の魂に入り込む様を見、祈るという行動こそが、神様に愛を本物で成熟したものへと涵養する。\n私達が神を愛するのは、神がまず私達を愛してくださったから。神からの愛は、信仰や行動による報酬ではない。\n私は他人とその心や魂の存在を疑っている。だから、他人を愛することへの確信がない。だから、信仰を持ち、行動をし、神を通して、その存在に確信を持ち、愛を実現させる。\n今日の勉強 sml 『Standard ML 入門』\n pp. 259 - 261  筆者が、なにをやるか、どうやるかを明示してくれているので、読者の自分は、自分が有能なのではと勘違いしてしまっているところがある。   問18.30  CopyDirStreamの以前の実装があるので、リストアップはできそう。 実装する方針は立てた。    isabelle Concrete Semantics\n Exercise 9.7をとき直そうと思い立つ  WhileTrueのケースの証明ができなくて詰まっていた 先人の回答をカンニングした。 条件を間違えていたことに気づいた。 erase_correctを終えたが、ほか2つの性質については示していない。   Sec_Typingの言わんとしていることを理解していないことがわかったので、次回以降はまた10章に戻る。  カンニングしてわかったこととして、以下の書き方がある。\nproof (csses) assume \u0026quot;A\u0026quot; ... next assume \u0026quot;\\not A\u0026quot; ... qed と同じことは\nproof (csses \u0026quot;A\u0026quot;) case True ... next case False ... qed というのが使えることがわかった。\n"},{"ref":"https://2222-42.github.io/2020/10/17/20201017log/","title":"20201017log","section":"post","date":"2020.10.17","body":"勤勉であるためには休息が必要である。\n勤勉であるためには、週のうち1日を休息に割り当てることが必要であると覚え(神様だって世界創造の後に1日何もしない日を設けた)、 毎週土曜日は休息の日としている。\ndiary 今日は料理もせず、服も畳まず、また、時間通りに動くことを意識せず、自分の意志の思うままに動いた。\n遊ぶのではなく、休む。この時間の流れに身を置いた。\n人間関係での覚え 最近は『Team Geek』を読んでいたり、また今後の人生について考えたりして、人との関係についてよく考える。\n人との関係は神との関係の延長である。\nまず第一に主を愛し、そして隣人を愛する。神と人との関係は垂直的な関係性であり、人間同士の関係は平行的な関係である。\nそして、神との関係、人との関係で重要なのは、共有される愛と情愛、そして、その愛を実行に移すことである。これらの根本的要素がないと関係性は成功しない。\n隣人に対して、共有されている愛や情愛を、実行に移すことこそ、神の御心に触れることである。\n主を愛し、兄弟姉妹である隣人に、その愛を実行しよう。\n今日の勉強 sml 『Standard ML 入門』\n p. 259  問18.29は現在のSMLが日本語文字をUNI-8に変換してくれているので飛ばした。   問18.28  ダブルクオーテーションとシングルクオーテーションの両方に対応する 型があるおかげで、修正範囲が明確になって、かつ簡単に解くことができた。    isabelle Concrete Semantics\n p.151 lemma \u0026ldquo;D_mono\u0026rdquo; と theorem \u0026ldquo;D_presevation\u0026rdquo; の証明。  証明を追いかけることはできた。    team 『Team Geek』 pp.99-117 (4章)\n チーム文化に含めないことについての話 チーム文化について  私はチーム文化を作ったことがなく、また、ある文化に属しているという自覚もない。 それならば、せめて有害な振る舞いを私がしていないか振り返り、そしてHRTの原則に従って礼儀正しく振舞おう。(礼儀正しさと冗長さのバランスはどう取る？という疑問はある)   チームの脅威の種類。主に、注意と集中のリスク。  他人の時間の尊重。私はもはやslackですら、それほど通知を出したくない。(もしそれが必要であるならば、それは仕組みやチームの文化を見直した方がいいと感じたからだ) 異なる視点の受入や妥協をすること。 また、チームの脅威という点では、自分のスクリーンネームが曖昧であることが気になった。   有害な振る舞いを文化から追放する方法(追放するのは人ではない)  完璧主義には方向性を与える。 トロルに餌を与えない。 感情的にならない(感情的になったことが何度かあるから、ファクトベースでとらえ、悪意ではなく無知を見出そう) プロジェクトの長期的な視点でのメリットや、衝突は有益な方法で解決できるかを、考える。(期間や有益さはチームの文化にとってどうかである)   無能(無知)で十分説明されることに悪意を見出すなというハンロンの剃刀を覚えておこう。  話の中で、興味深かったのは、高い技術力よりもその人のチームとの協調性とを有線する場合があることである。 その人がチームの文化と一致しない場合や、さらには有害である場合は、その人やその人の意見は追い出される。 なぜなら、技術がある人は替えが効きやすく、しかし、その文化に馴染む人は希少性が高いから。 そして、彼らの重視している文化、謙虚、尊敬、信頼というのが、全体の効率性を上げ、また、プロダクトの向上に繋がるからである。\n"},{"ref":"https://2222-42.github.io/2020/10/16/20201016log/","title":"log","section":"post","date":"2020.10.16","body":"朝が寒すぎて、出社時の検温で、35度6分となってた。\n肌の表面温度が35度になっていただけである。そこから徐々に肌に熱が戻ってくるわけであるが、その過程でスーツが十分熱く感じるようになってしまった。\nさて、これからはもっと寒い季節になる。乾燥がひどくなると、風邪予防のためにはマスクが必須になるかと思う。\nマスクを付けるとじまんの口ひげがかくれてしまうので、残念なところはあるが、感染症予防のためにも、引き続きマスクが必要だ。\nまた、ビタミンＣはよく取らねばず、そして、アルコール接種は体調を崩しやすくする。だから、今日もレモンサワーの代わりにレモン炭酸水を飲んだ。(レモンサワーを作るために買ったJINROを消費できないのは残念であるが。)\ndiary 思考の激しさは舌に影響を及ぼす 午前中は思考が散らばっており、ツイートで多くをつぶやいた。\nツイートする内容が多いということは、思考が散らかっていることだと、自己を反省し、落ち着くために、お昼寝をした。\n昼寝によって、午後は思考がだいぶ安定するようになったと思う。\n舌（ツイート）は小さな器官であるが山火事を起こすものである。これをコントロールすることが重要である。\n黄金律 自分が行ってもらいたいことを他人にも行う、という黄金律がある。これはキリストの教えた中での優先事項の1つである。\nまた、Team Geekに記載があったが、すぐ問題解決モードに移行するのではなく、質問をするようにする、というプラクティスもある。\n今日は少しであるが、こうすればいい、と聞くのではなく、「その課題の命名ってあれに近いよね」とか「その課題って、私たちの日常で時々やっているものないかな」とか、言葉を変えて、質問するようにしてみた。 実際、私はこういう問いかけをしてもらいたい。 聞くには早く、語るに遅く、また怒るに遅く、というのは美徳の一つであろう。\nだから、もしかしたら、今日の振る舞いは黄金律に即し、かつ、よいチームメイトとして振舞えたのではないか、と思っている。\n今日の勉強 sml 『Standard ML 入門』\n pp. 258-259 問18.26  型の不一致については、テキストの記述に誤りがあった。 val nextRef : Types.url -\u0026gt; Types.source -\u0026gt; Types.url optionとあるが、Typesにはsourceの定義がされていないので、Lex.sourceとしなければならない。   問18.27  一応parseHtmlの実装はできた。 しかし、HTTPSに対応していないので、うまいことparseしてくれないというISSUEはある。 問題文を解くうえでは、本質的ではないので飛ばしてもよいだろうが、気持ちの問題として、実際にwebshを動かす際には対応したほうがいいだろう。    otp 会社で業務時間のうち、勉強する時間を設けてもよいことになっており、それでアプリを作っているわけだが、今日は二段階認証について勉強していた。\n二段階であればなんでもよいわけであり、メールにコードを飛ばすのでもよいわけである。 が、普段使っている二段階認証であるところのGoogle Authenticatorなどでどうやっているのか気になったので調べた(cf: ISSUE )。\n TOTPはHOTPを使っていること、  ここでの計算では、OTPの有効期間のdurationを設定している。 中間者による攻撃は未然には防げないから、この辺りは注意しないといけない。   HOTPは秘密鍵など任意のバイト列を共有し、それをシード値として用いて、サーバー側とクライアント側で同じOneTimePasswordを生成できるようにしていること  かなり単純なアルゴリズムである。   TOTPはHOTPのcount部分を時間を用いているので、サーバー側とクライアント側との間にある時間のズレについては多少許容される  実際、Google Authenticatorを使っていたら、表示されなくなった直後1秒か2秒くらいだったら時々通ることがあるのはこれであろう。    ここまで調べて、実際に勉強としてやるのは面倒なので、TOTPは使わないにせよ、TOTPで問題となっている一部について考慮して実装をしようと思う。\n(あと、そろそろ適当にService層に関数を追加しているので、ちゃんとServiceをもうちょっとわけて整理したい。全部必要だから突っ込んだれ、という感じはやめよう。) (ただ、この整理については、別のPRやISSUEの責務なので、二段階認証の実装が済んだらそれでやろうと思う。)\ngolang の map golangのmapをほとんど使っていなくて、え、どうするんだっけ、となり、自分の無知を晒しながら、ペアプロをした。\n適切なコメントをもらいつつ行えたので、本当に助かった。ナビゲーターには感謝の言葉を伝えた。\n感謝を伝えることは本当に気持ちの良いことである。\n"},{"ref":"https://2222-42.github.io/2020/10/15/20201015log/","title":"log","section":"post","date":"2020.10.15","body":"自分が本当に挑戦しているのか、わからない。(対アルコール)\n酒を連日飲むと、手に湿疹が出るからお酒を控えようと思いつつ、飲んでしまう日が多い。 控えることができない時というは、喉に乾きを覚えていたり、また疲れてアドレナリンを欲しているときであったりする。 (レモン炭酸水はごまかす為に丁度良いことは先日述べた通りである。)\nどうもアルコールについて挑戦していないように思える。それは、どうしようもならない問題について神に助けを求めていないという程度においてである。\n同様に、果たして、勉強において、仕事において、どうしようもならない問題に挑戦しているだろうか。\n私は全てを予測可能に、コントロールできる範囲にして、不明瞭なことやできないことを排除している。(時間通りに動き、日課をこなすことは、自分についてコントロールすることであり、これはかなりの程度効果がある。)\n挑戦していないわけではないが、どちらかというと、素早い失敗をしていないのではないだろうか？(もしくは、素早く失敗しすぎて、失敗に気づいていないのか？)\nまずはアルコールについて挑戦をし、どうすればいいかについて、神に助けを求める他ない実感を抱かねばならない。悔い改め、神のもとに立ち返るような。\n今日の勉強 sml 『Standard ML 入門』\n p. 255 pp. 257-258 問18.26 のnextRefの実装の一部を書く。  TextIOからExternalIOに変えることになったので、型が不一致しているので、それの修正をしなければならない。    cdk AWSのサービス構成の絵を描いて、それに従って、CDKに書いていく。CDKの書き方については、公式のドキュメントが丁寧であり、それに従いギャップを埋めていった。\nバージョンによって、だいぶ推奨される関数に変化があったりするので、望ましいものを書くためには、手心がいる感じだ。\nCDKについては、まだ私は挑戦をしていないと思う。\n"},{"ref":"https://2222-42.github.io/2020/10/14/20201014log/","title":"20201014log","section":"post","date":"2020.10.14","body":"レモンサワーよりもレモン果汁が好きである。\n昨晩ブログを投稿してから、酒を飲もうか悩んでいたところ、割り材のハイサワーレモンをそのまま飲んだ。 そして、改めて気づいたのだが、レモンサワーのアルコールよりも、レモンの炭酸水が好きであることだ。\n酒を飲んで、身に覚えのある失敗をしたことは山ほどあるのだから。\nlog SML 『Standard ML入門』 pp. 252-255\n 問18.20  CM.makeの問題を解決   URLに対する入出力処理に関して  テキストに書いてあるコードを写経 lynxをinstallしておいた 問18.21と問18.22の解答を作成    Isabelle \u0026ldquo;Concrete Semantis\u0026rdquo; pp.149-151\nDef_Init_Smallを読んでいる\n 定理だけコピペして、テキストを読みながら、そこから証明を構成することをやろうとしている。 一部、sledgehammerでは生成されない証明があることについて、彼らはどうやって解いているのだろうか。  自らのひらめきだろうか？    Team 『Team Geek』 pp.63-95 (3章)\n 自らがアンチパターンに陥っていないかと、普段の自分を客観視できていないことへの不安  人間の問題を無視していないか 自分自身がパフォーマンスの低い人ではないか 仕事において友達として同僚に接していないか、線引きをうまくできていないか   人にお願いしたり相談を受けたりしているときに、よいチームメイトであるだろうか  エゴがないだろうか。 相談を受けて、すぐ問題解決モードに突入しがちで、相手を誘導するためのうまい質問をできているだろうか。 誉め言葉のサンドイッチを使っていないだろうか？　難しいフィードバックを適切に伝えられていないのではないだろうか？    diary Goalについて 運命の場所にたどり着かねばならない。 そのためには、自分のなりたい像のクリアなビジョンを抱かねばならない。 しかし、私には、そんなビジョンが全くなく、一方で、やりたいことばかりがある。\n時間は有限である。 やりたいことからやることを選択するためには、自分のなりたい像のクリアなビジョンがなければそれができない。 そして、それをしなければ、何もしなかった人間しか残らない。\n私は一体何者になりたいのか。どういう人になりたいのか。\nこの問をずっと繰り返している。\nWSL WSL2のおかげで、Windowsは比較的良い開発環境であると思う。\nApple製品を選択する理由が、Appleのデザインと固定資産としての期待値以外なくなりつつある。\n"},{"ref":"https://2222-42.github.io/2020/10/14/what-i-failed-to-use-cm/","title":"What I Failed to Use CM","section":"post","date":"2020.10.14","body":"昨日、CM.make が失敗するというISSUEを建てたが、それの原因がわかった。\n発生していた問題は、分割コンパイルしているところで、StandardMLのBasis Libraryがautoloadされておらず、unbound structure: X in path ...というエラーメッセージが表示され、コンパイルができなかったことである。\n原因と対処方法 SMLのライブラリはかなり破壊的な変更が加えられているので、『Standard ML入門』が書かれていた時期とはライブラリーの基本的な関数の引数やその型が変わっていることが多く見受けられる。\nそこで、CMの新しいライブラリのpdfを読んで、そこに含まれるサンプルコードを見れば、以下のような記述がある。\nGroup is xxx.sml yyy.sml $/basis.cm 上記の通りに設定すれあ、分割コンパイルは成功した。\n残っている疑問点 なお、CM.Library.known()で出力されるリストにはbasis.cmが含まれているし、失敗するところでのautoloadにも表示されているが、なぜかは不明。\n教訓 公式ドキュメントを読もう。\n"},{"ref":"https://2222-42.github.io/2020/10/13/20201013log/","title":"20201013log","section":"post","date":"2020.10.13","body":"汚い言葉ではなく、感謝の言葉を。舌は山火事のもとである。\n舌を制御する 心は身体に左右される。また、舌は人体においては小さな器官であるが、自分の心のみならず、他人の心を巻き込み、まるで山火事を起こすようなものである。\nだから、自分の発する言葉には最新の注意を払い、清い言葉を口に出そう。聞くに早く、語るに遅く、また怒るに遅くあろう。\n私の口癖は「くそ」だったり「死にたい」だったりする。これらの汚い言葉を発する原因を考え、今一度、綺麗な言葉、また感謝の言葉に治そう。\n今日起きたことは、自分の無力さや無知を感じたとき、心が落ち込んだら、「死にたい」と感じたら、それに気づかせてくれた人や事柄に感謝しよう。\nAWS CDK 今日はCDKであれこれしようとして、色々とどれをしたらいいのだろうかわからなくなった。\nその際に、ペアプロで、適切な助言をいただき、それにより、自分がAWSのサービスについて詳しくないことに気づいた。\n私はこのとき、自分の無知さによって、「死にたい」という言葉から口から出そうになった。また、それに類似した言葉を出した。\nしかし、改めて、それをSlackにおいてその「死にたい」という言葉が出るようなきっかけを気づかせてくれたことに、感謝を伝えた。\n帰宅してからも、自分の無力感に襲われていた。しかし、改めて、その感情に向き合い、改めて、そのことに気づかせてくれたペアプロの時間、そしてコメントをくれた人に感謝の気持ちを抱いた。 主よ、感謝します。どうか、聖なる生活を送らせてください。\nやりたいと気づいたこと AWSのサービスについてある程度の認識を持ちたい(「必要である」や、「やらねばならない」というのはできれば言葉にするのは避けたい。それは災いを招くから。)。\n ALB, target-group, ECS, container, これらの連関、そしてそれらをどう設定しているから実現されているのか、 また、これまでGUIでなんとなくできていたが、これをCDKのレベルで実現するにはどうするか  具体的には、CDKでどう書いたら、これまで触っていたGUIと同等のことができるのか、の一つ一つの対応関係について    今日の勉強 sml 『Standard ML 入門』のpp.251-252、18.9節「分割コンパイル」の箇所。\n問18.20の分割コンパイルのところで、よくわらからないエラーに遭遇した。本書が書かれた20年前とはだいぶライブラリーも事情も変わっているので、自分で調べて自分で直さなければならない。\nISSUEはこちら。\n公式のCMのドキュメントを読みつつ直していこう。\n"},{"ref":"https://2222-42.github.io/2020/10/12/what-i-learned-from-using-hugo/","title":"What I Learned from Using Hugo","section":"post","date":"2020.10.12","body":"Hugoをローカルに入れたくなくて、docker imageを使うことにしたが、それを使って行く中で気づいた、私の知らなかったことリスト。\nわかったこと わかっていなかったことが複数見つかった。\n Dockerとdocker-composeのことがよくわかっていない。  docker-compose で、複数の設定をどう使うか、知らなかった。  -f 指定はbuildに対しては利用できないとか。   image名の重複が発生したときのエラーがどういうものか、などを知らなかった。   git のことをよくわかってない  submoduleがどういうものかわかっていなかった。-\u0026gt; なんとなく使い方はわかった。 staged changeをgitがどう管理されているかわかっていない。  素朴にaddしたりcommitしたりしているが、どうgitがそれを管理しているのかよくわからない。      今後やりたいこと  CIで自動デプロイさせたい。 "},{"ref":"https://2222-42.github.io/2020/10/11/first-post/","title":"First Post","section":"post","date":"2020.10.11","body":"これは私の投稿です。\nwho 九鹿四十二だったり、ルグランだったり、大王だったりする人間のweblogです。\nwhat このweblogで記録すること：\n 日々の勉強のログ(e.g., 『Standard ML 入門』の読書状況)  および、その整理とアウトプット   考えていることの整理  現在やっていること やっていること:\n プログラミング  Ruby Standard ML Golang   形式手法  TLA+  並行して分散合意アルゴリズムに関して学習中   Isabelle   チーム  よいチームメイトとして振舞えるようになるため。    Appendix 使用したツール このブログを構築するのに使ったのは以下の通りである。\n Docker Hugo "}]