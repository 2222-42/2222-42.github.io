<!doctype html><html lang=jp><head><meta charset=utf-8><title>log-of-studying-rust-1</title><meta name=description content="2222-42's weblog"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://2222-42.github.io/index.xml title="Que Lock Si Jeus Nee"><link id=dark-mode-theme rel=stylesheet href=https://2222-42.github.io/css/dark.css><link rel=stylesheet href=https://2222-42.github.io/fontawesome/css/all.min.css><script src=https://2222-42.github.io/js/bundle.js></script><script src=https://2222-42.github.io/js/instantpage.js type=module defer></script><meta name=generator content="Hugo 0.74.3"><meta property="og:title" content="log-of-studying-rust-1"><meta property="og:description" content="15日から18日の分までのrustの勉強記録
TRPL pp.286-303"><meta property="og:type" content="article"><meta property="og:url" content="https://2222-42.github.io/2020/12/23/log-of-studying-rust-1/"><meta property="og:image" content="https://2222-42.github.io/myIcon.jpg"><meta property="article:published_time" content="2020-12-23T10:15:37+00:00"><meta property="article:modified_time" content="2020-12-23T10:15:37+00:00"><meta property="og:site_name" content="Que Lock Si Jeus Nee"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://2222-42.github.io/myIcon.jpg"><meta name=twitter:title content="log-of-studying-rust-1"><meta name=twitter:description content="15日から18日の分までのrustの勉強記録
TRPL pp.286-303"></head><body><header><nav class=navbar><div class=nav><a href=https://2222-42.github.io/ class=nav-logo><img src=https://2222-42.github.io/images/myIcon.jpg width=50 height=50 alt=Logo></a><ul class=nav-links><li><a href=/about/ name=About><i class="fas fa-user fa-lg"></i></a></li><li><a href=/tags/ name=Tags><i class="fas fa-tag fa-lg"></i></a></li><li><a href=/search/ name=Search><i class="fas fa-search fa-lg"></i></a></li></ul></div></nav><div class=intro-header><div class=container><div class=post-heading><h1>log-of-studying-rust-1</h1><span class=meta-post><i class="fa fa-calendar-alt"></i>&nbsp;Dec 23, 2020</span></div></div></div></header><div class=container role=main><article class=article class=blog-post><p>15日から18日の分までのrustの勉強記録</p><p><em>TRPL</em> pp.286-303</p><h2 id=12章の続き>12章の続き</h2><p>コマンドラインオプションではなく、代わりに環境変数を使用するように変更する</p><p>TDD:</p><ol><li>失敗するテストを書く</li><li>古いテストを変更し、すでに実装済みの機能を誤って壊してしまわないことを保証</li><li>失敗する実装を作る</li><li>実装する</li></ol><p>使っていたメソッド:</p><ul><li><code>to_lowercase</code><ul><li>Stringを返す。<ul><li>新しいデータ、新しいStringのメモリを確保している</li></ul></li></ul></li><li><code>contains</code><ul><li>これのシグニチャは文字列slice<ul><li>なので、Stringを渡すときは<code>&</code>をつける必要があった</li></ul></li></ul></li><li><code>env::var</code>を使う<ul><li>環境変数がsetされていたらOk列挙子を</li><li>セットされていなかったらErr列挙子を返す</li></ul></li><li><code>is_err</code>を使う<ul><li>Errだったらtrueを返す<ul><li>この場合は、セットされていたらfalseを返すことになる。</li></ul></li><li>値は関係ない場合は、unwrap, expect, Resultのメソッドは使う必要はない</li></ul></li></ul><p>引数と環境変数で同じ設定を行うことができるプログラム、そして、どちらが優先されるかを決定している、そんなプログラムを作る課題は解いた。</p><h3 id=出力について>出力について</h3><ul><li>標準出力(stdout): 普通の情報用</li><li>標準エラー出力(stderr): エラーメッセージ用</li></ul><p>この差異のおかげで、エラーメッセージを画面に表示しつつ、プログラムが成功して出力をファイルに李大レスことすることをユーザーは選択できる。</p><p>どのように標準出力に書き込まれているか。</p><ul><li>標準エラーストリームはリダイレクトせず、全て画面に表示され続ける</li><li>コマンドラインプログラムはエラーメッセージを標準エラー出力に送信することを期待する</li><li>標準出力の場合、<code>></code>と<code>file名</code>でfile名のfileにリダイレクトされ、保存される</li></ul><p>求めるもの: エラーメッセージは標準エラーに出力され、成功した状態のデータのみはファイルに残ること</p><p>標準エラーストリームに出力するマクロ<code>eprintln!</code>(標準出力ストリームではない)</p><h2 id=13章>13章</h2><p>関数型言語に影響された機能の一部、</p><ul><li>クロージャ: 変数に保存できる関数に似た文保要素</li><li>イテレータ: 一連の要素を処理する方法</li></ul><h3 id=クロージャ>クロージャ</h3><p>クロージャは</p><ul><li>変数に保存したり、引数として他の関数に渡すことのできる匿名関数<ul><li>ある場所でクロージャを生成し、</li><li>そこから別の文脈でクロージャを呼び出して評価できる</li></ul></li><li>関数と異なり、呼び出されたスコープの値をキャプチャできる</li></ul><p>時間のかかる関数を2回呼び出しているケースで、どうやってリファクタしていくかで使い方を学んでいく。</p><h4 id=関数でリファクタリング>関数でリファクタリング</h4><p>関数への重複した呼び出しの結果を変数に抽出しよう</p><p>結果が本当に必要なところだけコードを実行したい</p><h4 id=クロージャでリファクタリング>クロージャでリファクタリング</h4><p>呼び出しの結果を保存するのではなく、コードを定義するクロージャを変数に保存する</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>x<span style=color:#f92672>|</span> {
    ...
    v
};
</code></pre></div><ul><li>クロージャーのlet文は<ul><li>結果の値ではなく、</li><li>匿名関数の定義を含むことを意味する</li></ul></li><li>let文なので末尾に<code>;</code>が必要</li><li>一組の縦棒で、縦棒の中にクロージャーの仮引数を指定</li><li>関数の定義と同様に<ul><li>クロージャー本体が式1つなら<code>{</code>、<code>}</code>を省略可能</li><li><code>{...}</code>で関数の本体を書く<ul><li>返り値を返すなら最終行に指定</li></ul></li></ul></li><li>クロージャは関数のように呼び出せる</li></ul><p>複数回コードを呼び出す問題の再修正については、クロージャーが解決策を提供する。</p><h3 id=クロージャ定義に型注釈がない理由およびクロージャに関わるトレイトについて>クロージャ定義に型注釈がない理由、および、クロージャに関わるトレイトについて</h3><ul><li>関数<ul><li>ユーザーに露出する明示的なインターフェイスの一部<ul><li>型を注釈する必要がある</li></ul></li></ul></li><li>クロージャ<ul><li>露出するインターフェイスには使用されない短く狭い文脈でのみ関係する<ul><li>型を注釈する必要がない</li><li>注釈を加えることもできる</li></ul></li></ul></li></ul><p>クロージャ定義には、引数それぞれと戻り値に大して推論される具体的な型が1つある。
だから、2つの異なる型でクロージャーの呼び出しを試みると、1つ目の呼び出しの時点で型が推論されるので、2つ目の呼び出しで型エラーとなる。</p><div class=blog-tags><a href=https://2222-42.github.io//tags/rust/>rust</a>&nbsp;</div></article></div><footer><div><a href=https://twitter.com/9_6_42 name=twitter><em class="fab fa-twitter"></em></a><a href=https://github.com/2222-42 name=github><em class="fab fa-github"></em></a></div><div class=container><p class="credits copyright"><a href=https://2222-42.github.io/about>2222-42</a>
&nbsp;&copy;
2021
&nbsp;/&nbsp;
<a href=https://2222-42.github.io/>Que Lock Si Jeus Nee</a>
&nbsp;&ndash;&nbsp;
<i class="fas fa-moon" id=dark-mode-toggle></i><p class="credits theme-by"><a href=https://gohugo.io>Hugo</a>&nbsp;
<a href=https://github.com/matsuyoshi30/harbor>Harbor</a></p></p></div></footer></body></html>